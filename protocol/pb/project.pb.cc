// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: project.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "project.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace CBR {

void protobuf_ShutdownFile_project_2eproto() {
  delete npcdata::default_instance_;
  delete RegisterGateToHallRes::default_instance_;
  delete RegisterGateToHallReq::default_instance_;
  delete RegisterHallToDbReq::default_instance_;
  delete RegisterHallToDbRes::default_instance_;
  delete UpRoleDataReq::default_instance_;
  delete UpRoleDataRes::default_instance_;
  delete DownRoleDataReq::default_instance_;
  delete DownRoleDataRes::default_instance_;
  delete ChickDinnerSaveData::default_instance_;
  delete ChickDinnerSaveDataArg::default_instance_;
  delete ChickDinnerSaveDataRes::default_instance_;
  delete RegisterGateToLoginArg::default_instance_;
  delete RegisterGateToLoginRes::default_instance_;
  delete ChickDinnerQueryDataArg::default_instance_;
  delete ChickDinnerQueryDataRes::default_instance_;
  delete RegAccountArg::default_instance_;
  delete RegAccountRes::default_instance_;
  delete LoginDataArg::default_instance_;
  delete LoginDataRes::default_instance_;
  delete appear::default_instance_;
  delete AttriBase::default_instance_;
  delete ActorBase::default_instance_;
  delete LoginSession2Gate::default_instance_;
  delete EnterGameArg::default_instance_;
  delete EnterGameRes::default_instance_;
  delete ActorDataArg::default_instance_;
  delete ActorDataRes::default_instance_;
  delete CreateActorReq::default_instance_;
  delete CreateActorRes::default_instance_;
  delete LoginOutData::default_instance_;
  delete UserSaveData::default_instance_;
  delete ActorInfo::default_instance_;
  delete ActorBrief::default_instance_;
  delete UpdateActorDataArg::default_instance_;
  delete UpdateActorDataRes::default_instance_;
  delete ClientAuthArg::default_instance_;
  delete ClientAuthRes::default_instance_;
  delete HeartbeatData::default_instance_;
  delete Friend2Db::default_instance_;
  delete RegisterHallToDcmArg::default_instance_;
  delete RegisterHallToDcmRes::default_instance_;
  delete StartMatchArg::default_instance_;
  delete StartMatchRes::default_instance_;
  delete MatchPlayer::default_instance_;
  delete MatchResult::default_instance_;
  delete MatchRobot::default_instance_;
  delete RoomInfo::default_instance_;
  delete CancelMatchArg::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_project_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_project_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::CBR::protobuf_AddDesc_enum_2eproto();
  npcdata::default_instance_ = new npcdata();
  RegisterGateToHallRes::default_instance_ = new RegisterGateToHallRes();
  RegisterGateToHallReq::default_instance_ = new RegisterGateToHallReq();
  RegisterHallToDbReq::default_instance_ = new RegisterHallToDbReq();
  RegisterHallToDbRes::default_instance_ = new RegisterHallToDbRes();
  UpRoleDataReq::default_instance_ = new UpRoleDataReq();
  UpRoleDataRes::default_instance_ = new UpRoleDataRes();
  DownRoleDataReq::default_instance_ = new DownRoleDataReq();
  DownRoleDataRes::default_instance_ = new DownRoleDataRes();
  ChickDinnerSaveData::default_instance_ = new ChickDinnerSaveData();
  ChickDinnerSaveDataArg::default_instance_ = new ChickDinnerSaveDataArg();
  ChickDinnerSaveDataRes::default_instance_ = new ChickDinnerSaveDataRes();
  RegisterGateToLoginArg::default_instance_ = new RegisterGateToLoginArg();
  RegisterGateToLoginRes::default_instance_ = new RegisterGateToLoginRes();
  ChickDinnerQueryDataArg::default_instance_ = new ChickDinnerQueryDataArg();
  ChickDinnerQueryDataRes::default_instance_ = new ChickDinnerQueryDataRes();
  RegAccountArg::default_instance_ = new RegAccountArg();
  RegAccountRes::default_instance_ = new RegAccountRes();
  LoginDataArg::default_instance_ = new LoginDataArg();
  LoginDataRes::default_instance_ = new LoginDataRes();
  appear::default_instance_ = new appear();
  AttriBase::default_instance_ = new AttriBase();
  ActorBase::default_instance_ = new ActorBase();
  LoginSession2Gate::default_instance_ = new LoginSession2Gate();
  EnterGameArg::default_instance_ = new EnterGameArg();
  EnterGameRes::default_instance_ = new EnterGameRes();
  ActorDataArg::default_instance_ = new ActorDataArg();
  ActorDataRes::default_instance_ = new ActorDataRes();
  CreateActorReq::default_instance_ = new CreateActorReq();
  CreateActorRes::default_instance_ = new CreateActorRes();
  LoginOutData::default_instance_ = new LoginOutData();
  UserSaveData::default_instance_ = new UserSaveData();
  ActorInfo::default_instance_ = new ActorInfo();
  ActorBrief::default_instance_ = new ActorBrief();
  UpdateActorDataArg::default_instance_ = new UpdateActorDataArg();
  UpdateActorDataRes::default_instance_ = new UpdateActorDataRes();
  ClientAuthArg::default_instance_ = new ClientAuthArg();
  ClientAuthRes::default_instance_ = new ClientAuthRes();
  HeartbeatData::default_instance_ = new HeartbeatData();
  Friend2Db::default_instance_ = new Friend2Db();
  RegisterHallToDcmArg::default_instance_ = new RegisterHallToDcmArg();
  RegisterHallToDcmRes::default_instance_ = new RegisterHallToDcmRes();
  StartMatchArg::default_instance_ = new StartMatchArg();
  StartMatchRes::default_instance_ = new StartMatchRes();
  MatchPlayer::default_instance_ = new MatchPlayer();
  MatchResult::default_instance_ = new MatchResult();
  MatchRobot::default_instance_ = new MatchRobot();
  RoomInfo::default_instance_ = new RoomInfo();
  CancelMatchArg::default_instance_ = new CancelMatchArg();
  npcdata::default_instance_->InitAsDefaultInstance();
  RegisterGateToHallRes::default_instance_->InitAsDefaultInstance();
  RegisterGateToHallReq::default_instance_->InitAsDefaultInstance();
  RegisterHallToDbReq::default_instance_->InitAsDefaultInstance();
  RegisterHallToDbRes::default_instance_->InitAsDefaultInstance();
  UpRoleDataReq::default_instance_->InitAsDefaultInstance();
  UpRoleDataRes::default_instance_->InitAsDefaultInstance();
  DownRoleDataReq::default_instance_->InitAsDefaultInstance();
  DownRoleDataRes::default_instance_->InitAsDefaultInstance();
  ChickDinnerSaveData::default_instance_->InitAsDefaultInstance();
  ChickDinnerSaveDataArg::default_instance_->InitAsDefaultInstance();
  ChickDinnerSaveDataRes::default_instance_->InitAsDefaultInstance();
  RegisterGateToLoginArg::default_instance_->InitAsDefaultInstance();
  RegisterGateToLoginRes::default_instance_->InitAsDefaultInstance();
  ChickDinnerQueryDataArg::default_instance_->InitAsDefaultInstance();
  ChickDinnerQueryDataRes::default_instance_->InitAsDefaultInstance();
  RegAccountArg::default_instance_->InitAsDefaultInstance();
  RegAccountRes::default_instance_->InitAsDefaultInstance();
  LoginDataArg::default_instance_->InitAsDefaultInstance();
  LoginDataRes::default_instance_->InitAsDefaultInstance();
  appear::default_instance_->InitAsDefaultInstance();
  AttriBase::default_instance_->InitAsDefaultInstance();
  ActorBase::default_instance_->InitAsDefaultInstance();
  LoginSession2Gate::default_instance_->InitAsDefaultInstance();
  EnterGameArg::default_instance_->InitAsDefaultInstance();
  EnterGameRes::default_instance_->InitAsDefaultInstance();
  ActorDataArg::default_instance_->InitAsDefaultInstance();
  ActorDataRes::default_instance_->InitAsDefaultInstance();
  CreateActorReq::default_instance_->InitAsDefaultInstance();
  CreateActorRes::default_instance_->InitAsDefaultInstance();
  LoginOutData::default_instance_->InitAsDefaultInstance();
  UserSaveData::default_instance_->InitAsDefaultInstance();
  ActorInfo::default_instance_->InitAsDefaultInstance();
  ActorBrief::default_instance_->InitAsDefaultInstance();
  UpdateActorDataArg::default_instance_->InitAsDefaultInstance();
  UpdateActorDataRes::default_instance_->InitAsDefaultInstance();
  ClientAuthArg::default_instance_->InitAsDefaultInstance();
  ClientAuthRes::default_instance_->InitAsDefaultInstance();
  HeartbeatData::default_instance_->InitAsDefaultInstance();
  Friend2Db::default_instance_->InitAsDefaultInstance();
  RegisterHallToDcmArg::default_instance_->InitAsDefaultInstance();
  RegisterHallToDcmRes::default_instance_->InitAsDefaultInstance();
  StartMatchArg::default_instance_->InitAsDefaultInstance();
  StartMatchRes::default_instance_->InitAsDefaultInstance();
  MatchPlayer::default_instance_->InitAsDefaultInstance();
  MatchResult::default_instance_->InitAsDefaultInstance();
  MatchRobot::default_instance_->InitAsDefaultInstance();
  RoomInfo::default_instance_->InitAsDefaultInstance();
  CancelMatchArg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_project_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_project_2eproto_once_);
void protobuf_AddDesc_project_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_project_2eproto_once_,
                 &protobuf_AddDesc_project_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_project_2eproto {
  StaticDescriptorInitializer_project_2eproto() {
    protobuf_AddDesc_project_2eproto();
  }
} static_descriptor_initializer_project_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int npcdata::kIdFieldNumber;
const int npcdata::kBuffFieldNumber;
const int npcdata::kAppearFieldNumber;
const int npcdata::kFfFieldNumber;
#endif  // !_MSC_VER

npcdata::npcdata()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void npcdata::InitAsDefaultInstance() {
}

npcdata::npcdata(const npcdata& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void npcdata::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  buff_ = 0u;
  appear_ = 0;
  ff_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

npcdata::~npcdata() {
  SharedDtor();
}

void npcdata::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void npcdata::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const npcdata& npcdata::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

npcdata* npcdata::default_instance_ = NULL;

npcdata* npcdata::New() const {
  return new npcdata;
}

void npcdata::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    buff_ = 0u;
    appear_ = 0;
    ff_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool npcdata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_buff;
        break;
      }

      // optional uint32 buff = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buff:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buff_)));
          set_has_buff();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_appear;
        break;
      }

      // optional int32 appear = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_appear:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &appear_)));
          set_has_appear();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ff;
        break;
      }

      // optional int64 ff = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ff:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &ff_)));
          set_has_ff();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void npcdata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional uint32 buff = 2;
  if (has_buff()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->buff(), output);
  }

  // optional int32 appear = 3;
  if (has_appear()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->appear(), output);
  }

  // optional int64 ff = 4;
  if (has_ff()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->ff(), output);
  }

}

int npcdata::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional uint32 buff = 2;
    if (has_buff()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buff());
    }

    // optional int32 appear = 3;
    if (has_appear()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->appear());
    }

    // optional int64 ff = 4;
    if (has_ff()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->ff());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void npcdata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const npcdata*>(&from));
}

void npcdata::MergeFrom(const npcdata& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_buff()) {
      set_buff(from.buff());
    }
    if (from.has_appear()) {
      set_appear(from.appear());
    }
    if (from.has_ff()) {
      set_ff(from.ff());
    }
  }
}

void npcdata::CopyFrom(const npcdata& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool npcdata::IsInitialized() const {

  return true;
}

void npcdata::Swap(npcdata* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(buff_, other->buff_);
    std::swap(appear_, other->appear_);
    std::swap(ff_, other->ff_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string npcdata::GetTypeName() const {
  return "CBR.npcdata";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterGateToHallRes::kResultFieldNumber;
#endif  // !_MSC_VER

RegisterGateToHallRes::RegisterGateToHallRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterGateToHallRes::InitAsDefaultInstance() {
}

RegisterGateToHallRes::RegisterGateToHallRes(const RegisterGateToHallRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterGateToHallRes::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterGateToHallRes::~RegisterGateToHallRes() {
  SharedDtor();
}

void RegisterGateToHallRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterGateToHallRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterGateToHallRes& RegisterGateToHallRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegisterGateToHallRes* RegisterGateToHallRes::default_instance_ = NULL;

RegisterGateToHallRes* RegisterGateToHallRes::New() const {
  return new RegisterGateToHallRes;
}

void RegisterGateToHallRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterGateToHallRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_result(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterGateToHallRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

}

int RegisterGateToHallRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterGateToHallRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterGateToHallRes*>(&from));
}

void RegisterGateToHallRes::MergeFrom(const RegisterGateToHallRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void RegisterGateToHallRes::CopyFrom(const RegisterGateToHallRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterGateToHallRes::IsInitialized() const {

  return true;
}

void RegisterGateToHallRes::Swap(RegisterGateToHallRes* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterGateToHallRes::GetTypeName() const {
  return "CBR.RegisterGateToHallRes";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterGateToHallReq::kZoneidFieldNumber;
const int RegisterGateToHallReq::kServeridFieldNumber;
#endif  // !_MSC_VER

RegisterGateToHallReq::RegisterGateToHallReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterGateToHallReq::InitAsDefaultInstance() {
}

RegisterGateToHallReq::RegisterGateToHallReq(const RegisterGateToHallReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterGateToHallReq::SharedCtor() {
  _cached_size_ = 0;
  zoneid_ = 0u;
  serverid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterGateToHallReq::~RegisterGateToHallReq() {
  SharedDtor();
}

void RegisterGateToHallReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterGateToHallReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterGateToHallReq& RegisterGateToHallReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegisterGateToHallReq* RegisterGateToHallReq::default_instance_ = NULL;

RegisterGateToHallReq* RegisterGateToHallReq::New() const {
  return new RegisterGateToHallReq;
}

void RegisterGateToHallReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zoneid_ = 0u;
    serverid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterGateToHallReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 zoneid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &zoneid_)));
          set_has_zoneid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_serverid;
        break;
      }

      // optional uint32 serverid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_serverid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serverid_)));
          set_has_serverid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterGateToHallReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 zoneid = 1;
  if (has_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->zoneid(), output);
  }

  // optional uint32 serverid = 2;
  if (has_serverid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->serverid(), output);
  }

}

int RegisterGateToHallReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 zoneid = 1;
    if (has_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->zoneid());
    }

    // optional uint32 serverid = 2;
    if (has_serverid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serverid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterGateToHallReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterGateToHallReq*>(&from));
}

void RegisterGateToHallReq::MergeFrom(const RegisterGateToHallReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zoneid()) {
      set_zoneid(from.zoneid());
    }
    if (from.has_serverid()) {
      set_serverid(from.serverid());
    }
  }
}

void RegisterGateToHallReq::CopyFrom(const RegisterGateToHallReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterGateToHallReq::IsInitialized() const {

  return true;
}

void RegisterGateToHallReq::Swap(RegisterGateToHallReq* other) {
  if (other != this) {
    std::swap(zoneid_, other->zoneid_);
    std::swap(serverid_, other->serverid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterGateToHallReq::GetTypeName() const {
  return "CBR.RegisterGateToHallReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterHallToDbReq::kServeridFieldNumber;
const int RegisterHallToDbReq::kNameFieldNumber;
#endif  // !_MSC_VER

RegisterHallToDbReq::RegisterHallToDbReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterHallToDbReq::InitAsDefaultInstance() {
}

RegisterHallToDbReq::RegisterHallToDbReq(const RegisterHallToDbReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterHallToDbReq::SharedCtor() {
  _cached_size_ = 0;
  serverid_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterHallToDbReq::~RegisterHallToDbReq() {
  SharedDtor();
}

void RegisterHallToDbReq::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterHallToDbReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterHallToDbReq& RegisterHallToDbReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegisterHallToDbReq* RegisterHallToDbReq::default_instance_ = NULL;

RegisterHallToDbReq* RegisterHallToDbReq::New() const {
  return new RegisterHallToDbReq;
}

void RegisterHallToDbReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    serverid_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterHallToDbReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 serverid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serverid_)));
          set_has_serverid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterHallToDbReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 serverid = 1;
  if (has_serverid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serverid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

}

int RegisterHallToDbReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 serverid = 1;
    if (has_serverid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serverid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterHallToDbReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterHallToDbReq*>(&from));
}

void RegisterHallToDbReq::MergeFrom(const RegisterHallToDbReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serverid()) {
      set_serverid(from.serverid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void RegisterHallToDbReq::CopyFrom(const RegisterHallToDbReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterHallToDbReq::IsInitialized() const {

  return true;
}

void RegisterHallToDbReq::Swap(RegisterHallToDbReq* other) {
  if (other != this) {
    std::swap(serverid_, other->serverid_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterHallToDbReq::GetTypeName() const {
  return "CBR.RegisterHallToDbReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterHallToDbRes::kRetFieldNumber;
#endif  // !_MSC_VER

RegisterHallToDbRes::RegisterHallToDbRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterHallToDbRes::InitAsDefaultInstance() {
}

RegisterHallToDbRes::RegisterHallToDbRes(const RegisterHallToDbRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterHallToDbRes::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterHallToDbRes::~RegisterHallToDbRes() {
  SharedDtor();
}

void RegisterHallToDbRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterHallToDbRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterHallToDbRes& RegisterHallToDbRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegisterHallToDbRes* RegisterHallToDbRes::default_instance_ = NULL;

RegisterHallToDbRes* RegisterHallToDbRes::New() const {
  return new RegisterHallToDbRes;
}

void RegisterHallToDbRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterHallToDbRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_ret(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterHallToDbRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->ret(), output);
  }

}

int RegisterHallToDbRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ret());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterHallToDbRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterHallToDbRes*>(&from));
}

void RegisterHallToDbRes::MergeFrom(const RegisterHallToDbRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
}

void RegisterHallToDbRes::CopyFrom(const RegisterHallToDbRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterHallToDbRes::IsInitialized() const {

  return true;
}

void RegisterHallToDbRes::Swap(RegisterHallToDbRes* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterHallToDbRes::GetTypeName() const {
  return "CBR.RegisterHallToDbRes";
}


// ===================================================================

#ifndef _MSC_VER
const int UpRoleDataReq::kRoleidFieldNumber;
const int UpRoleDataReq::kNameFieldNumber;
const int UpRoleDataReq::kScoreFieldNumber;
const int UpRoleDataReq::kKillerFieldNumber;
#endif  // !_MSC_VER

UpRoleDataReq::UpRoleDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpRoleDataReq::InitAsDefaultInstance() {
}

UpRoleDataReq::UpRoleDataReq(const UpRoleDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpRoleDataReq::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  score_ = 0u;
  killer_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpRoleDataReq::~UpRoleDataReq() {
  SharedDtor();
}

void UpRoleDataReq::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpRoleDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpRoleDataReq& UpRoleDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

UpRoleDataReq* UpRoleDataReq::default_instance_ = NULL;

UpRoleDataReq* UpRoleDataReq::New() const {
  return new UpRoleDataReq;
}

void UpRoleDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roleid_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    score_ = 0u;
    killer_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpRoleDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_score;
        break;
      }

      // optional uint32 score = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_killer;
        break;
      }

      // optional uint32 killer = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_killer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &killer_)));
          set_has_killer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpRoleDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional uint32 score = 3;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->score(), output);
  }

  // optional uint32 killer = 4;
  if (has_killer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->killer(), output);
  }

}

int UpRoleDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 score = 3;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // optional uint32 killer = 4;
    if (has_killer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->killer());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpRoleDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpRoleDataReq*>(&from));
}

void UpRoleDataReq::MergeFrom(const UpRoleDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_killer()) {
      set_killer(from.killer());
    }
  }
}

void UpRoleDataReq::CopyFrom(const UpRoleDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpRoleDataReq::IsInitialized() const {

  return true;
}

void UpRoleDataReq::Swap(UpRoleDataReq* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(name_, other->name_);
    std::swap(score_, other->score_);
    std::swap(killer_, other->killer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpRoleDataReq::GetTypeName() const {
  return "CBR.UpRoleDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int UpRoleDataRes::kErrorFieldNumber;
#endif  // !_MSC_VER

UpRoleDataRes::UpRoleDataRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpRoleDataRes::InitAsDefaultInstance() {
}

UpRoleDataRes::UpRoleDataRes(const UpRoleDataRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpRoleDataRes::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpRoleDataRes::~UpRoleDataRes() {
  SharedDtor();
}

void UpRoleDataRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpRoleDataRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpRoleDataRes& UpRoleDataRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

UpRoleDataRes* UpRoleDataRes::default_instance_ = NULL;

UpRoleDataRes* UpRoleDataRes::New() const {
  return new UpRoleDataRes;
}

void UpRoleDataRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpRoleDataRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpRoleDataRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error(), output);
  }

}

int UpRoleDataRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpRoleDataRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpRoleDataRes*>(&from));
}

void UpRoleDataRes::MergeFrom(const UpRoleDataRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
  }
}

void UpRoleDataRes::CopyFrom(const UpRoleDataRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpRoleDataRes::IsInitialized() const {

  return true;
}

void UpRoleDataRes::Swap(UpRoleDataRes* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpRoleDataRes::GetTypeName() const {
  return "CBR.UpRoleDataRes";
}


// ===================================================================

#ifndef _MSC_VER
const int DownRoleDataReq::kRoleidFieldNumber;
#endif  // !_MSC_VER

DownRoleDataReq::DownRoleDataReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DownRoleDataReq::InitAsDefaultInstance() {
}

DownRoleDataReq::DownRoleDataReq(const DownRoleDataReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DownRoleDataReq::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DownRoleDataReq::~DownRoleDataReq() {
  SharedDtor();
}

void DownRoleDataReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DownRoleDataReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DownRoleDataReq& DownRoleDataReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

DownRoleDataReq* DownRoleDataReq::default_instance_ = NULL;

DownRoleDataReq* DownRoleDataReq::New() const {
  return new DownRoleDataReq;
}

void DownRoleDataReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roleid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DownRoleDataReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DownRoleDataReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

}

int DownRoleDataReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DownRoleDataReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DownRoleDataReq*>(&from));
}

void DownRoleDataReq::MergeFrom(const DownRoleDataReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
  }
}

void DownRoleDataReq::CopyFrom(const DownRoleDataReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownRoleDataReq::IsInitialized() const {

  return true;
}

void DownRoleDataReq::Swap(DownRoleDataReq* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DownRoleDataReq::GetTypeName() const {
  return "CBR.DownRoleDataReq";
}


// ===================================================================

#ifndef _MSC_VER
const int DownRoleDataRes::kRoleidFieldNumber;
const int DownRoleDataRes::kNameFieldNumber;
const int DownRoleDataRes::kScoreFieldNumber;
const int DownRoleDataRes::kKillerFieldNumber;
#endif  // !_MSC_VER

DownRoleDataRes::DownRoleDataRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DownRoleDataRes::InitAsDefaultInstance() {
}

DownRoleDataRes::DownRoleDataRes(const DownRoleDataRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DownRoleDataRes::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  score_ = 0u;
  killer_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DownRoleDataRes::~DownRoleDataRes() {
  SharedDtor();
}

void DownRoleDataRes::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DownRoleDataRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DownRoleDataRes& DownRoleDataRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

DownRoleDataRes* DownRoleDataRes::default_instance_ = NULL;

DownRoleDataRes* DownRoleDataRes::New() const {
  return new DownRoleDataRes;
}

void DownRoleDataRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roleid_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    score_ = 0u;
    killer_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DownRoleDataRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_score;
        break;
      }

      // optional uint32 score = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_killer;
        break;
      }

      // optional uint32 killer = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_killer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &killer_)));
          set_has_killer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DownRoleDataRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional uint32 score = 3;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->score(), output);
  }

  // optional uint32 killer = 4;
  if (has_killer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->killer(), output);
  }

}

int DownRoleDataRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 score = 3;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

    // optional uint32 killer = 4;
    if (has_killer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->killer());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DownRoleDataRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DownRoleDataRes*>(&from));
}

void DownRoleDataRes::MergeFrom(const DownRoleDataRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_killer()) {
      set_killer(from.killer());
    }
  }
}

void DownRoleDataRes::CopyFrom(const DownRoleDataRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownRoleDataRes::IsInitialized() const {

  return true;
}

void DownRoleDataRes::Swap(DownRoleDataRes* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(name_, other->name_);
    std::swap(score_, other->score_);
    std::swap(killer_, other->killer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DownRoleDataRes::GetTypeName() const {
  return "CBR.DownRoleDataRes";
}


// ===================================================================

#ifndef _MSC_VER
const int ChickDinnerSaveData::kRoleidFieldNumber;
const int ChickDinnerSaveData::kNameFieldNumber;
const int ChickDinnerSaveData::kKillerFieldNumber;
const int ChickDinnerSaveData::kScoreFieldNumber;
#endif  // !_MSC_VER

ChickDinnerSaveData::ChickDinnerSaveData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChickDinnerSaveData::InitAsDefaultInstance() {
}

ChickDinnerSaveData::ChickDinnerSaveData(const ChickDinnerSaveData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChickDinnerSaveData::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  killer_ = 0u;
  score_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChickDinnerSaveData::~ChickDinnerSaveData() {
  SharedDtor();
}

void ChickDinnerSaveData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChickDinnerSaveData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChickDinnerSaveData& ChickDinnerSaveData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ChickDinnerSaveData* ChickDinnerSaveData::default_instance_ = NULL;

ChickDinnerSaveData* ChickDinnerSaveData::New() const {
  return new ChickDinnerSaveData;
}

void ChickDinnerSaveData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roleid_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    killer_ = 0u;
    score_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChickDinnerSaveData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_killer;
        break;
      }

      // optional uint32 killer = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_killer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &killer_)));
          set_has_killer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_score;
        break;
      }

      // optional uint64 score = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChickDinnerSaveData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional uint32 killer = 3;
  if (has_killer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->killer(), output);
  }

  // optional uint64 score = 4;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->score(), output);
  }

}

int ChickDinnerSaveData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 killer = 3;
    if (has_killer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->killer());
    }

    // optional uint64 score = 4;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->score());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChickDinnerSaveData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChickDinnerSaveData*>(&from));
}

void ChickDinnerSaveData::MergeFrom(const ChickDinnerSaveData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_killer()) {
      set_killer(from.killer());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
  }
}

void ChickDinnerSaveData::CopyFrom(const ChickDinnerSaveData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChickDinnerSaveData::IsInitialized() const {

  return true;
}

void ChickDinnerSaveData::Swap(ChickDinnerSaveData* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(name_, other->name_);
    std::swap(killer_, other->killer_);
    std::swap(score_, other->score_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChickDinnerSaveData::GetTypeName() const {
  return "CBR.ChickDinnerSaveData";
}


// ===================================================================

#ifndef _MSC_VER
const int ChickDinnerSaveDataArg::kTypeFieldNumber;
const int ChickDinnerSaveDataArg::kDataFieldNumber;
#endif  // !_MSC_VER

ChickDinnerSaveDataArg::ChickDinnerSaveDataArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChickDinnerSaveDataArg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_ = const_cast< ::CBR::ChickDinnerSaveData*>(
      ::CBR::ChickDinnerSaveData::internal_default_instance());
#else
  data_ = const_cast< ::CBR::ChickDinnerSaveData*>(&::CBR::ChickDinnerSaveData::default_instance());
#endif
}

ChickDinnerSaveDataArg::ChickDinnerSaveDataArg(const ChickDinnerSaveDataArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChickDinnerSaveDataArg::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChickDinnerSaveDataArg::~ChickDinnerSaveDataArg() {
  SharedDtor();
}

void ChickDinnerSaveDataArg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_;
  }
}

void ChickDinnerSaveDataArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChickDinnerSaveDataArg& ChickDinnerSaveDataArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ChickDinnerSaveDataArg* ChickDinnerSaveDataArg::default_instance_ = NULL;

ChickDinnerSaveDataArg* ChickDinnerSaveDataArg::New() const {
  return new ChickDinnerSaveDataArg;
}

void ChickDinnerSaveDataArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_data()) {
      if (data_ != NULL) data_->::CBR::ChickDinnerSaveData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChickDinnerSaveDataArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.DBOperType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::DBOperType_IsValid(value)) {
            set_type(static_cast< ::CBR::DBOperType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // optional .CBR.ChickDinnerSaveData data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChickDinnerSaveDataArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.DBOperType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .CBR.ChickDinnerSaveData data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(), output);
  }

}

int ChickDinnerSaveDataArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.DBOperType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .CBR.ChickDinnerSaveData data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChickDinnerSaveDataArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChickDinnerSaveDataArg*>(&from));
}

void ChickDinnerSaveDataArg::MergeFrom(const ChickDinnerSaveDataArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_data()) {
      mutable_data()->::CBR::ChickDinnerSaveData::MergeFrom(from.data());
    }
  }
}

void ChickDinnerSaveDataArg::CopyFrom(const ChickDinnerSaveDataArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChickDinnerSaveDataArg::IsInitialized() const {

  return true;
}

void ChickDinnerSaveDataArg::Swap(ChickDinnerSaveDataArg* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChickDinnerSaveDataArg::GetTypeName() const {
  return "CBR.ChickDinnerSaveDataArg";
}


// ===================================================================

#ifndef _MSC_VER
const int ChickDinnerSaveDataRes::kResultFieldNumber;
#endif  // !_MSC_VER

ChickDinnerSaveDataRes::ChickDinnerSaveDataRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChickDinnerSaveDataRes::InitAsDefaultInstance() {
}

ChickDinnerSaveDataRes::ChickDinnerSaveDataRes(const ChickDinnerSaveDataRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChickDinnerSaveDataRes::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChickDinnerSaveDataRes::~ChickDinnerSaveDataRes() {
  SharedDtor();
}

void ChickDinnerSaveDataRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChickDinnerSaveDataRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChickDinnerSaveDataRes& ChickDinnerSaveDataRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ChickDinnerSaveDataRes* ChickDinnerSaveDataRes::default_instance_ = NULL;

ChickDinnerSaveDataRes* ChickDinnerSaveDataRes::New() const {
  return new ChickDinnerSaveDataRes;
}

void ChickDinnerSaveDataRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChickDinnerSaveDataRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_result(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChickDinnerSaveDataRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

}

int ChickDinnerSaveDataRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChickDinnerSaveDataRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChickDinnerSaveDataRes*>(&from));
}

void ChickDinnerSaveDataRes::MergeFrom(const ChickDinnerSaveDataRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ChickDinnerSaveDataRes::CopyFrom(const ChickDinnerSaveDataRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChickDinnerSaveDataRes::IsInitialized() const {

  return true;
}

void ChickDinnerSaveDataRes::Swap(ChickDinnerSaveDataRes* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChickDinnerSaveDataRes::GetTypeName() const {
  return "CBR.ChickDinnerSaveDataRes";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterGateToLoginArg::kServeridFieldNumber;
const int RegisterGateToLoginArg::kNameFieldNumber;
const int RegisterGateToLoginArg::kIpFieldNumber;
const int RegisterGateToLoginArg::kPortFieldNumber;
#endif  // !_MSC_VER

RegisterGateToLoginArg::RegisterGateToLoginArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterGateToLoginArg::InitAsDefaultInstance() {
}

RegisterGateToLoginArg::RegisterGateToLoginArg(const RegisterGateToLoginArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterGateToLoginArg::SharedCtor() {
  _cached_size_ = 0;
  serverid_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterGateToLoginArg::~RegisterGateToLoginArg() {
  SharedDtor();
}

void RegisterGateToLoginArg::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterGateToLoginArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterGateToLoginArg& RegisterGateToLoginArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegisterGateToLoginArg* RegisterGateToLoginArg::default_instance_ = NULL;

RegisterGateToLoginArg* RegisterGateToLoginArg::New() const {
  return new RegisterGateToLoginArg;
}

void RegisterGateToLoginArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    serverid_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterGateToLoginArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 serverid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serverid_)));
          set_has_serverid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ip;
        break;
      }

      // optional string ip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_port;
        break;
      }

      // optional uint32 port = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterGateToLoginArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 serverid = 1;
  if (has_serverid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serverid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional string ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->ip(), output);
  }

  // optional uint32 port = 4;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->port(), output);
  }

}

int RegisterGateToLoginArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 serverid = 1;
    if (has_serverid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serverid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string ip = 3;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional uint32 port = 4;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterGateToLoginArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterGateToLoginArg*>(&from));
}

void RegisterGateToLoginArg::MergeFrom(const RegisterGateToLoginArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serverid()) {
      set_serverid(from.serverid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
}

void RegisterGateToLoginArg::CopyFrom(const RegisterGateToLoginArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterGateToLoginArg::IsInitialized() const {

  return true;
}

void RegisterGateToLoginArg::Swap(RegisterGateToLoginArg* other) {
  if (other != this) {
    std::swap(serverid_, other->serverid_);
    std::swap(name_, other->name_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterGateToLoginArg::GetTypeName() const {
  return "CBR.RegisterGateToLoginArg";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterGateToLoginRes::kResultFieldNumber;
#endif  // !_MSC_VER

RegisterGateToLoginRes::RegisterGateToLoginRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterGateToLoginRes::InitAsDefaultInstance() {
}

RegisterGateToLoginRes::RegisterGateToLoginRes(const RegisterGateToLoginRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterGateToLoginRes::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterGateToLoginRes::~RegisterGateToLoginRes() {
  SharedDtor();
}

void RegisterGateToLoginRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterGateToLoginRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterGateToLoginRes& RegisterGateToLoginRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegisterGateToLoginRes* RegisterGateToLoginRes::default_instance_ = NULL;

RegisterGateToLoginRes* RegisterGateToLoginRes::New() const {
  return new RegisterGateToLoginRes;
}

void RegisterGateToLoginRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterGateToLoginRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_result(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterGateToLoginRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

}

int RegisterGateToLoginRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterGateToLoginRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterGateToLoginRes*>(&from));
}

void RegisterGateToLoginRes::MergeFrom(const RegisterGateToLoginRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void RegisterGateToLoginRes::CopyFrom(const RegisterGateToLoginRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterGateToLoginRes::IsInitialized() const {

  return true;
}

void RegisterGateToLoginRes::Swap(RegisterGateToLoginRes* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterGateToLoginRes::GetTypeName() const {
  return "CBR.RegisterGateToLoginRes";
}


// ===================================================================

#ifndef _MSC_VER
const int ChickDinnerQueryDataArg::kRoleidFieldNumber;
#endif  // !_MSC_VER

ChickDinnerQueryDataArg::ChickDinnerQueryDataArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChickDinnerQueryDataArg::InitAsDefaultInstance() {
}

ChickDinnerQueryDataArg::ChickDinnerQueryDataArg(const ChickDinnerQueryDataArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChickDinnerQueryDataArg::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChickDinnerQueryDataArg::~ChickDinnerQueryDataArg() {
  SharedDtor();
}

void ChickDinnerQueryDataArg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChickDinnerQueryDataArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChickDinnerQueryDataArg& ChickDinnerQueryDataArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ChickDinnerQueryDataArg* ChickDinnerQueryDataArg::default_instance_ = NULL;

ChickDinnerQueryDataArg* ChickDinnerQueryDataArg::New() const {
  return new ChickDinnerQueryDataArg;
}

void ChickDinnerQueryDataArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roleid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChickDinnerQueryDataArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChickDinnerQueryDataArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

}

int ChickDinnerQueryDataArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChickDinnerQueryDataArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChickDinnerQueryDataArg*>(&from));
}

void ChickDinnerQueryDataArg::MergeFrom(const ChickDinnerQueryDataArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
  }
}

void ChickDinnerQueryDataArg::CopyFrom(const ChickDinnerQueryDataArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChickDinnerQueryDataArg::IsInitialized() const {

  return true;
}

void ChickDinnerQueryDataArg::Swap(ChickDinnerQueryDataArg* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChickDinnerQueryDataArg::GetTypeName() const {
  return "CBR.ChickDinnerQueryDataArg";
}


// ===================================================================

#ifndef _MSC_VER
const int ChickDinnerQueryDataRes::kDataFieldNumber;
const int ChickDinnerQueryDataRes::kErrorFieldNumber;
#endif  // !_MSC_VER

ChickDinnerQueryDataRes::ChickDinnerQueryDataRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChickDinnerQueryDataRes::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_ = const_cast< ::CBR::ChickDinnerSaveData*>(
      ::CBR::ChickDinnerSaveData::internal_default_instance());
#else
  data_ = const_cast< ::CBR::ChickDinnerSaveData*>(&::CBR::ChickDinnerSaveData::default_instance());
#endif
}

ChickDinnerQueryDataRes::ChickDinnerQueryDataRes(const ChickDinnerQueryDataRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChickDinnerQueryDataRes::SharedCtor() {
  _cached_size_ = 0;
  data_ = NULL;
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChickDinnerQueryDataRes::~ChickDinnerQueryDataRes() {
  SharedDtor();
}

void ChickDinnerQueryDataRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_;
  }
}

void ChickDinnerQueryDataRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChickDinnerQueryDataRes& ChickDinnerQueryDataRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ChickDinnerQueryDataRes* ChickDinnerQueryDataRes::default_instance_ = NULL;

ChickDinnerQueryDataRes* ChickDinnerQueryDataRes::New() const {
  return new ChickDinnerQueryDataRes;
}

void ChickDinnerQueryDataRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_data()) {
      if (data_ != NULL) data_->::CBR::ChickDinnerSaveData::Clear();
    }
    error_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChickDinnerQueryDataRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ChickDinnerSaveData data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_error;
        break;
      }

      // optional .CBR.ErrorCode error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChickDinnerQueryDataRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ChickDinnerSaveData data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(), output);
  }

  // optional .CBR.ErrorCode error = 2;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->error(), output);
  }

}

int ChickDinnerQueryDataRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ChickDinnerSaveData data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

    // optional .CBR.ErrorCode error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChickDinnerQueryDataRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChickDinnerQueryDataRes*>(&from));
}

void ChickDinnerQueryDataRes::MergeFrom(const ChickDinnerQueryDataRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      mutable_data()->::CBR::ChickDinnerSaveData::MergeFrom(from.data());
    }
    if (from.has_error()) {
      set_error(from.error());
    }
  }
}

void ChickDinnerQueryDataRes::CopyFrom(const ChickDinnerQueryDataRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChickDinnerQueryDataRes::IsInitialized() const {

  return true;
}

void ChickDinnerQueryDataRes::Swap(ChickDinnerQueryDataRes* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChickDinnerQueryDataRes::GetTypeName() const {
  return "CBR.ChickDinnerQueryDataRes";
}


// ===================================================================

#ifndef _MSC_VER
const int RegAccountArg::kNameFieldNumber;
const int RegAccountArg::kPasswordFieldNumber;
const int RegAccountArg::kChannnelFieldNumber;
const int RegAccountArg::kDeviceIdFieldNumber;
const int RegAccountArg::kIpFieldNumber;
#endif  // !_MSC_VER

RegAccountArg::RegAccountArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegAccountArg::InitAsDefaultInstance() {
}

RegAccountArg::RegAccountArg(const RegAccountArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegAccountArg::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channnel_ = 0;
  deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegAccountArg::~RegAccountArg() {
  SharedDtor();
}

void RegAccountArg::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegAccountArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegAccountArg& RegAccountArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegAccountArg* RegAccountArg::default_instance_ = NULL;

RegAccountArg* RegAccountArg::New() const {
  return new RegAccountArg;
}

void RegAccountArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::kEmptyString) {
        password_->clear();
      }
    }
    channnel_ = 0;
    if (has_deviceid()) {
      if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
        deviceid_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegAccountArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // optional string password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_channnel;
        break;
      }

      // optional .CBR.Channel channnel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channnel:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::Channel_IsValid(value)) {
            set_channnel(static_cast< ::CBR::Channel >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_DeviceId;
        break;
      }

      // optional string DeviceId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DeviceId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deviceid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ip;
        break;
      }

      // optional string ip = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegAccountArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->password(), output);
  }

  // optional .CBR.Channel channnel = 3;
  if (has_channnel()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->channnel(), output);
  }

  // optional string DeviceId = 4;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->deviceid(), output);
  }

  // optional string ip = 5;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->ip(), output);
  }

}

int RegAccountArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // optional .CBR.Channel channnel = 3;
    if (has_channnel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->channnel());
    }

    // optional string DeviceId = 4;
    if (has_deviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deviceid());
    }

    // optional string ip = 5;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegAccountArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegAccountArg*>(&from));
}

void RegAccountArg::MergeFrom(const RegAccountArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_channnel()) {
      set_channnel(from.channnel());
    }
    if (from.has_deviceid()) {
      set_deviceid(from.deviceid());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
  }
}

void RegAccountArg::CopyFrom(const RegAccountArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegAccountArg::IsInitialized() const {

  return true;
}

void RegAccountArg::Swap(RegAccountArg* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(password_, other->password_);
    std::swap(channnel_, other->channnel_);
    std::swap(deviceid_, other->deviceid_);
    std::swap(ip_, other->ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegAccountArg::GetTypeName() const {
  return "CBR.RegAccountArg";
}


// ===================================================================

#ifndef _MSC_VER
const int RegAccountRes::kErrorFieldNumber;
const int RegAccountRes::kAccountidFieldNumber;
#endif  // !_MSC_VER

RegAccountRes::RegAccountRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegAccountRes::InitAsDefaultInstance() {
}

RegAccountRes::RegAccountRes(const RegAccountRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegAccountRes::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  accountid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegAccountRes::~RegAccountRes() {
  SharedDtor();
}

void RegAccountRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegAccountRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegAccountRes& RegAccountRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegAccountRes* RegAccountRes::default_instance_ = NULL;

RegAccountRes* RegAccountRes::New() const {
  return new RegAccountRes;
}

void RegAccountRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_ = 0;
    accountid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegAccountRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_accountid;
        break;
      }

      // optional uint64 accountid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accountid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegAccountRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error(), output);
  }

  // optional uint64 accountid = 2;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->accountid(), output);
  }

}

int RegAccountRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

    // optional uint64 accountid = 2;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegAccountRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegAccountRes*>(&from));
}

void RegAccountRes::MergeFrom(const RegAccountRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
  }
}

void RegAccountRes::CopyFrom(const RegAccountRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegAccountRes::IsInitialized() const {

  return true;
}

void RegAccountRes::Swap(RegAccountRes* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(accountid_, other->accountid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegAccountRes::GetTypeName() const {
  return "CBR.RegAccountRes";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginDataArg::kNameFieldNumber;
const int LoginDataArg::kPasswardFieldNumber;
const int LoginDataArg::kDeviceidFieldNumber;
const int LoginDataArg::kIpFieldNumber;
#endif  // !_MSC_VER

LoginDataArg::LoginDataArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginDataArg::InitAsDefaultInstance() {
}

LoginDataArg::LoginDataArg(const LoginDataArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginDataArg::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  passward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginDataArg::~LoginDataArg() {
  SharedDtor();
}

void LoginDataArg::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (passward_ != &::google::protobuf::internal::kEmptyString) {
    delete passward_;
  }
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginDataArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginDataArg& LoginDataArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

LoginDataArg* LoginDataArg::default_instance_ = NULL;

LoginDataArg* LoginDataArg::New() const {
  return new LoginDataArg;
}

void LoginDataArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_passward()) {
      if (passward_ != &::google::protobuf::internal::kEmptyString) {
        passward_->clear();
      }
    }
    if (has_deviceid()) {
      if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
        deviceid_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginDataArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_passward;
        break;
      }

      // optional bytes passward = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_passward:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_passward()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_deviceid;
        break;
      }

      // optional string deviceid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_deviceid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deviceid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ip;
        break;
      }

      // optional string ip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginDataArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional bytes passward = 2;
  if (has_passward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->passward(), output);
  }

  // optional string deviceid = 3;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->deviceid(), output);
  }

  // optional string ip = 4;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->ip(), output);
  }

}

int LoginDataArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bytes passward = 2;
    if (has_passward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->passward());
    }

    // optional string deviceid = 3;
    if (has_deviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deviceid());
    }

    // optional string ip = 4;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginDataArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginDataArg*>(&from));
}

void LoginDataArg::MergeFrom(const LoginDataArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_passward()) {
      set_passward(from.passward());
    }
    if (from.has_deviceid()) {
      set_deviceid(from.deviceid());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
  }
}

void LoginDataArg::CopyFrom(const LoginDataArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginDataArg::IsInitialized() const {

  return true;
}

void LoginDataArg::Swap(LoginDataArg* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(passward_, other->passward_);
    std::swap(deviceid_, other->deviceid_);
    std::swap(ip_, other->ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginDataArg::GetTypeName() const {
  return "CBR.LoginDataArg";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginDataRes::kResultFieldNumber;
const int LoginDataRes::kIpFieldNumber;
const int LoginDataRes::kPortFieldNumber;
const int LoginDataRes::kSessionFieldNumber;
const int LoginDataRes::kAccoutidFieldNumber;
const int LoginDataRes::kAccountnameFieldNumber;
const int LoginDataRes::kStateFieldNumber;
const int LoginDataRes::kActorlistFieldNumber;
#endif  // !_MSC_VER

LoginDataRes::LoginDataRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginDataRes::InitAsDefaultInstance() {
}

LoginDataRes::LoginDataRes(const LoginDataRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginDataRes::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0u;
  session_ = GOOGLE_ULONGLONG(0);
  accoutid_ = GOOGLE_ULONGLONG(0);
  accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  state_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginDataRes::~LoginDataRes() {
  SharedDtor();
}

void LoginDataRes::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginDataRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginDataRes& LoginDataRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

LoginDataRes* LoginDataRes::default_instance_ = NULL;

LoginDataRes* LoginDataRes::New() const {
  return new LoginDataRes;
}

void LoginDataRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0u;
    session_ = GOOGLE_ULONGLONG(0);
    accoutid_ = GOOGLE_ULONGLONG(0);
    if (has_accountname()) {
      if (accountname_ != &::google::protobuf::internal::kEmptyString) {
        accountname_->clear();
      }
    }
    state_ = 0u;
  }
  actorlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginDataRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_result(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ip;
        break;
      }

      // optional string ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // optional uint32 port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_session;
        break;
      }

      // optional uint64 session = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_session:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_)));
          set_has_session();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_accoutid;
        break;
      }

      // optional uint64 accoutid = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accoutid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accoutid_)));
          set_has_accoutid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_accountname;
        break;
      }

      // optional string accountname = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_accountname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_accountname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_state;
        break;
      }

      // optional uint32 state = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_actorlist;
        break;
      }

      // repeated .CBR.ActorBrief actorlist = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_actorlist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_actorlist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_actorlist;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginDataRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->ip(), output);
  }

  // optional uint32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // optional uint64 session = 4;
  if (has_session()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->session(), output);
  }

  // optional uint64 accoutid = 5;
  if (has_accoutid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->accoutid(), output);
  }

  // optional string accountname = 6;
  if (has_accountname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->accountname(), output);
  }

  // optional uint32 state = 7;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->state(), output);
  }

  // repeated .CBR.ActorBrief actorlist = 8;
  for (int i = 0; i < this->actorlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->actorlist(i), output);
  }

}

int LoginDataRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional string ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional uint32 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // optional uint64 session = 4;
    if (has_session()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session());
    }

    // optional uint64 accoutid = 5;
    if (has_accoutid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accoutid());
    }

    // optional string accountname = 6;
    if (has_accountname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->accountname());
    }

    // optional uint32 state = 7;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

  }
  // repeated .CBR.ActorBrief actorlist = 8;
  total_size += 1 * this->actorlist_size();
  for (int i = 0; i < this->actorlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->actorlist(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginDataRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginDataRes*>(&from));
}

void LoginDataRes::MergeFrom(const LoginDataRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  actorlist_.MergeFrom(from.actorlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_session()) {
      set_session(from.session());
    }
    if (from.has_accoutid()) {
      set_accoutid(from.accoutid());
    }
    if (from.has_accountname()) {
      set_accountname(from.accountname());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
}

void LoginDataRes::CopyFrom(const LoginDataRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginDataRes::IsInitialized() const {

  return true;
}

void LoginDataRes::Swap(LoginDataRes* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(session_, other->session_);
    std::swap(accoutid_, other->accoutid_);
    std::swap(accountname_, other->accountname_);
    std::swap(state_, other->state_);
    actorlist_.Swap(&other->actorlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginDataRes::GetTypeName() const {
  return "CBR.LoginDataRes";
}


// ===================================================================

#ifndef _MSC_VER
const int appear::kActidFieldNumber;
const int appear::kActornameFieldNumber;
const int appear::kActortypeFieldNumber;
const int appear::kResidFieldNumber;
const int appear::kHairstyleFieldNumber;
const int appear::kCreatetimeFieldNumber;
const int appear::kSexFieldNumber;
const int appear::kSeqindexFieldNumber;
#endif  // !_MSC_VER

appear::appear()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void appear::InitAsDefaultInstance() {
}

appear::appear(const appear& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void appear::SharedCtor() {
  _cached_size_ = 0;
  actid_ = GOOGLE_ULONGLONG(0);
  actorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  actortype_ = 0u;
  resid_ = 0u;
  hairstyle_ = 0u;
  createtime_ = 0u;
  sex_ = 0u;
  seqindex_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

appear::~appear() {
  SharedDtor();
}

void appear::SharedDtor() {
  if (actorname_ != &::google::protobuf::internal::kEmptyString) {
    delete actorname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void appear::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const appear& appear::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

appear* appear::default_instance_ = NULL;

appear* appear::New() const {
  return new appear;
}

void appear::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    actid_ = GOOGLE_ULONGLONG(0);
    if (has_actorname()) {
      if (actorname_ != &::google::protobuf::internal::kEmptyString) {
        actorname_->clear();
      }
    }
    actortype_ = 0u;
    resid_ = 0u;
    hairstyle_ = 0u;
    createtime_ = 0u;
    sex_ = 0u;
    seqindex_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool appear::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 actid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &actid_)));
          set_has_actid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_actorname;
        break;
      }

      // optional string actorname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_actorname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_actorname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_actortype;
        break;
      }

      // optional uint32 actortype = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_actortype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &actortype_)));
          set_has_actortype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_resid;
        break;
      }

      // optional uint32 resid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_resid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &resid_)));
          set_has_resid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_hairstyle;
        break;
      }

      // optional uint32 hairstyle = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hairstyle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hairstyle_)));
          set_has_hairstyle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_createtime;
        break;
      }

      // optional uint32 createtime = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_createtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &createtime_)));
          set_has_createtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_sex;
        break;
      }

      // optional uint32 sex = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_seqindex;
        break;
      }

      // optional uint32 seqindex = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seqindex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seqindex_)));
          set_has_seqindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void appear::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 actid = 1;
  if (has_actid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->actid(), output);
  }

  // optional string actorname = 2;
  if (has_actorname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->actorname(), output);
  }

  // optional uint32 actortype = 3;
  if (has_actortype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->actortype(), output);
  }

  // optional uint32 resid = 4;
  if (has_resid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->resid(), output);
  }

  // optional uint32 hairstyle = 5;
  if (has_hairstyle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->hairstyle(), output);
  }

  // optional uint32 createtime = 6;
  if (has_createtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->createtime(), output);
  }

  // optional uint32 sex = 7;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->sex(), output);
  }

  // optional uint32 seqindex = 8;
  if (has_seqindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->seqindex(), output);
  }

}

int appear::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 actid = 1;
    if (has_actid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->actid());
    }

    // optional string actorname = 2;
    if (has_actorname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->actorname());
    }

    // optional uint32 actortype = 3;
    if (has_actortype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->actortype());
    }

    // optional uint32 resid = 4;
    if (has_resid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->resid());
    }

    // optional uint32 hairstyle = 5;
    if (has_hairstyle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hairstyle());
    }

    // optional uint32 createtime = 6;
    if (has_createtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->createtime());
    }

    // optional uint32 sex = 7;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sex());
    }

    // optional uint32 seqindex = 8;
    if (has_seqindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seqindex());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void appear::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const appear*>(&from));
}

void appear::MergeFrom(const appear& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_actid()) {
      set_actid(from.actid());
    }
    if (from.has_actorname()) {
      set_actorname(from.actorname());
    }
    if (from.has_actortype()) {
      set_actortype(from.actortype());
    }
    if (from.has_resid()) {
      set_resid(from.resid());
    }
    if (from.has_hairstyle()) {
      set_hairstyle(from.hairstyle());
    }
    if (from.has_createtime()) {
      set_createtime(from.createtime());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_seqindex()) {
      set_seqindex(from.seqindex());
    }
  }
}

void appear::CopyFrom(const appear& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool appear::IsInitialized() const {

  return true;
}

void appear::Swap(appear* other) {
  if (other != this) {
    std::swap(actid_, other->actid_);
    std::swap(actorname_, other->actorname_);
    std::swap(actortype_, other->actortype_);
    std::swap(resid_, other->resid_);
    std::swap(hairstyle_, other->hairstyle_);
    std::swap(createtime_, other->createtime_);
    std::swap(sex_, other->sex_);
    std::swap(seqindex_, other->seqindex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string appear::GetTypeName() const {
  return "CBR.appear";
}


// ===================================================================

#ifndef _MSC_VER
const int AttriBase::kActorLevelFieldNumber;
const int AttriBase::kActorExpFieldNumber;
const int AttriBase::kVigorFieldNumber;
const int AttriBase::kVipLevFieldNumber;
const int AttriBase::kFightingFieldNumber;
const int AttriBase::kFireFieldNumber;
const int AttriBase::kScoreFieldNumber;
#endif  // !_MSC_VER

AttriBase::AttriBase()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AttriBase::InitAsDefaultInstance() {
}

AttriBase::AttriBase(const AttriBase& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AttriBase::SharedCtor() {
  _cached_size_ = 0;
  actorlevel_ = 0u;
  actorexp_ = GOOGLE_ULONGLONG(0);
  vigor_ = 0u;
  viplev_ = 0u;
  fighting_ = 0u;
  fire_ = 0u;
  score_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AttriBase::~AttriBase() {
  SharedDtor();
}

void AttriBase::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AttriBase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AttriBase& AttriBase::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

AttriBase* AttriBase::default_instance_ = NULL;

AttriBase* AttriBase::New() const {
  return new AttriBase;
}

void AttriBase::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    actorlevel_ = 0u;
    actorexp_ = GOOGLE_ULONGLONG(0);
    vigor_ = 0u;
    viplev_ = 0u;
    fighting_ = 0u;
    fire_ = 0u;
    score_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AttriBase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ActorLevel = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &actorlevel_)));
          set_has_actorlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ActorExp;
        break;
      }

      // optional uint64 ActorExp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ActorExp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &actorexp_)));
          set_has_actorexp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Vigor;
        break;
      }

      // optional uint32 Vigor = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Vigor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vigor_)));
          set_has_vigor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_VipLev;
        break;
      }

      // optional uint32 VipLev = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_VipLev:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &viplev_)));
          set_has_viplev();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Fighting;
        break;
      }

      // optional uint32 Fighting = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Fighting:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fighting_)));
          set_has_fighting();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_Fire;
        break;
      }

      // optional uint32 Fire = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Fire:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fire_)));
          set_has_fire();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_score;
        break;
      }

      // optional uint32 score = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AttriBase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 ActorLevel = 1;
  if (has_actorlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->actorlevel(), output);
  }

  // optional uint64 ActorExp = 2;
  if (has_actorexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->actorexp(), output);
  }

  // optional uint32 Vigor = 3;
  if (has_vigor()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->vigor(), output);
  }

  // optional uint32 VipLev = 4;
  if (has_viplev()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->viplev(), output);
  }

  // optional uint32 Fighting = 5;
  if (has_fighting()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->fighting(), output);
  }

  // optional uint32 Fire = 6;
  if (has_fire()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->fire(), output);
  }

  // optional uint32 score = 7;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->score(), output);
  }

}

int AttriBase::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ActorLevel = 1;
    if (has_actorlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->actorlevel());
    }

    // optional uint64 ActorExp = 2;
    if (has_actorexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->actorexp());
    }

    // optional uint32 Vigor = 3;
    if (has_vigor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->vigor());
    }

    // optional uint32 VipLev = 4;
    if (has_viplev()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->viplev());
    }

    // optional uint32 Fighting = 5;
    if (has_fighting()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fighting());
    }

    // optional uint32 Fire = 6;
    if (has_fire()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fire());
    }

    // optional uint32 score = 7;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->score());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AttriBase::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AttriBase*>(&from));
}

void AttriBase::MergeFrom(const AttriBase& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_actorlevel()) {
      set_actorlevel(from.actorlevel());
    }
    if (from.has_actorexp()) {
      set_actorexp(from.actorexp());
    }
    if (from.has_vigor()) {
      set_vigor(from.vigor());
    }
    if (from.has_viplev()) {
      set_viplev(from.viplev());
    }
    if (from.has_fighting()) {
      set_fighting(from.fighting());
    }
    if (from.has_fire()) {
      set_fire(from.fire());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
  }
}

void AttriBase::CopyFrom(const AttriBase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttriBase::IsInitialized() const {

  return true;
}

void AttriBase::Swap(AttriBase* other) {
  if (other != this) {
    std::swap(actorlevel_, other->actorlevel_);
    std::swap(actorexp_, other->actorexp_);
    std::swap(vigor_, other->vigor_);
    std::swap(viplev_, other->viplev_);
    std::swap(fighting_, other->fighting_);
    std::swap(fire_, other->fire_);
    std::swap(score_, other->score_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AttriBase::GetTypeName() const {
  return "CBR.AttriBase";
}


// ===================================================================

#ifndef _MSC_VER
const int ActorBase::kAccountidFieldNumber;
const int ActorBase::kAppFieldNumber;
const int ActorBase::kAttFieldNumber;
const int ActorBase::kVerionFieldNumber;
const int ActorBase::kTimeFieldNumber;
#endif  // !_MSC_VER

ActorBase::ActorBase()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ActorBase::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  app_ = const_cast< ::CBR::appear*>(
      ::CBR::appear::internal_default_instance());
#else
  app_ = const_cast< ::CBR::appear*>(&::CBR::appear::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  att_ = const_cast< ::CBR::AttriBase*>(
      ::CBR::AttriBase::internal_default_instance());
#else
  att_ = const_cast< ::CBR::AttriBase*>(&::CBR::AttriBase::default_instance());
#endif
}

ActorBase::ActorBase(const ActorBase& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ActorBase::SharedCtor() {
  _cached_size_ = 0;
  accountid_ = GOOGLE_ULONGLONG(0);
  app_ = NULL;
  att_ = NULL;
  verion_ = 0u;
  time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActorBase::~ActorBase() {
  SharedDtor();
}

void ActorBase::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete app_;
    delete att_;
  }
}

void ActorBase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActorBase& ActorBase::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ActorBase* ActorBase::default_instance_ = NULL;

ActorBase* ActorBase::New() const {
  return new ActorBase;
}

void ActorBase::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    accountid_ = GOOGLE_ULONGLONG(0);
    if (has_app()) {
      if (app_ != NULL) app_->::CBR::appear::Clear();
    }
    if (has_att()) {
      if (att_ != NULL) att_->::CBR::AttriBase::Clear();
    }
    verion_ = 0u;
    time_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ActorBase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 accountid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_app;
        break;
      }

      // optional .CBR.appear app = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_app:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_app()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_att;
        break;
      }

      // optional .CBR.AttriBase att = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_att:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_att()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_verion;
        break;
      }

      // optional uint32 verion = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_verion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &verion_)));
          set_has_verion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_time;
        break;
      }

      // optional uint32 time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ActorBase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 accountid = 1;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->accountid(), output);
  }

  // optional .CBR.appear app = 2;
  if (has_app()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->app(), output);
  }

  // optional .CBR.AttriBase att = 3;
  if (has_att()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->att(), output);
  }

  // optional uint32 verion = 4;
  if (has_verion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->verion(), output);
  }

  // optional uint32 time = 5;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->time(), output);
  }

}

int ActorBase::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 accountid = 1;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

    // optional .CBR.appear app = 2;
    if (has_app()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->app());
    }

    // optional .CBR.AttriBase att = 3;
    if (has_att()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->att());
    }

    // optional uint32 verion = 4;
    if (has_verion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->verion());
    }

    // optional uint32 time = 5;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActorBase::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActorBase*>(&from));
}

void ActorBase::MergeFrom(const ActorBase& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
    if (from.has_app()) {
      mutable_app()->::CBR::appear::MergeFrom(from.app());
    }
    if (from.has_att()) {
      mutable_att()->::CBR::AttriBase::MergeFrom(from.att());
    }
    if (from.has_verion()) {
      set_verion(from.verion());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void ActorBase::CopyFrom(const ActorBase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorBase::IsInitialized() const {

  return true;
}

void ActorBase::Swap(ActorBase* other) {
  if (other != this) {
    std::swap(accountid_, other->accountid_);
    std::swap(app_, other->app_);
    std::swap(att_, other->att_);
    std::swap(verion_, other->verion_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActorBase::GetTypeName() const {
  return "CBR.ActorBase";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginSession2Gate::kSessionFieldNumber;
const int LoginSession2Gate::kTimeFieldNumber;
const int LoginSession2Gate::kAccountidFieldNumber;
const int LoginSession2Gate::kAccountnameFieldNumber;
#endif  // !_MSC_VER

LoginSession2Gate::LoginSession2Gate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginSession2Gate::InitAsDefaultInstance() {
}

LoginSession2Gate::LoginSession2Gate(const LoginSession2Gate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginSession2Gate::SharedCtor() {
  _cached_size_ = 0;
  session_ = GOOGLE_ULONGLONG(0);
  time_ = 0u;
  accountid_ = GOOGLE_ULONGLONG(0);
  accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginSession2Gate::~LoginSession2Gate() {
  SharedDtor();
}

void LoginSession2Gate::SharedDtor() {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginSession2Gate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginSession2Gate& LoginSession2Gate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

LoginSession2Gate* LoginSession2Gate::default_instance_ = NULL;

LoginSession2Gate* LoginSession2Gate::New() const {
  return new LoginSession2Gate;
}

void LoginSession2Gate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    session_ = GOOGLE_ULONGLONG(0);
    time_ = 0u;
    accountid_ = GOOGLE_ULONGLONG(0);
    if (has_accountname()) {
      if (accountname_ != &::google::protobuf::internal::kEmptyString) {
        accountname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginSession2Gate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 session = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_)));
          set_has_session();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_time;
        break;
      }

      // optional uint32 time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_accountid;
        break;
      }

      // optional uint64 accountid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accountid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_accountname;
        break;
      }

      // optional string accountname = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_accountname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_accountname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginSession2Gate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 session = 1;
  if (has_session()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session(), output);
  }

  // optional uint32 time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time(), output);
  }

  // optional uint64 accountid = 3;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->accountid(), output);
  }

  // optional string accountname = 4;
  if (has_accountname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->accountname(), output);
  }

}

int LoginSession2Gate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 session = 1;
    if (has_session()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session());
    }

    // optional uint32 time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // optional uint64 accountid = 3;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

    // optional string accountname = 4;
    if (has_accountname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->accountname());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginSession2Gate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginSession2Gate*>(&from));
}

void LoginSession2Gate::MergeFrom(const LoginSession2Gate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session()) {
      set_session(from.session());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
    if (from.has_accountname()) {
      set_accountname(from.accountname());
    }
  }
}

void LoginSession2Gate::CopyFrom(const LoginSession2Gate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginSession2Gate::IsInitialized() const {

  return true;
}

void LoginSession2Gate::Swap(LoginSession2Gate* other) {
  if (other != this) {
    std::swap(session_, other->session_);
    std::swap(time_, other->time_);
    std::swap(accountid_, other->accountid_);
    std::swap(accountname_, other->accountname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginSession2Gate::GetTypeName() const {
  return "CBR.LoginSession2Gate";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterGameArg::kAccountidFieldNumber;
const int EnterGameArg::kTokenFieldNumber;
const int EnterGameArg::kActoridFieldNumber;
#endif  // !_MSC_VER

EnterGameArg::EnterGameArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterGameArg::InitAsDefaultInstance() {
}

EnterGameArg::EnterGameArg(const EnterGameArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterGameArg::SharedCtor() {
  _cached_size_ = 0;
  accountid_ = GOOGLE_ULONGLONG(0);
  token_ = GOOGLE_ULONGLONG(0);
  actorid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterGameArg::~EnterGameArg() {
  SharedDtor();
}

void EnterGameArg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterGameArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterGameArg& EnterGameArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

EnterGameArg* EnterGameArg::default_instance_ = NULL;

EnterGameArg* EnterGameArg::New() const {
  return new EnterGameArg;
}

void EnterGameArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    accountid_ = GOOGLE_ULONGLONG(0);
    token_ = GOOGLE_ULONGLONG(0);
    actorid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterGameArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 accountid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_token;
        break;
      }

      // optional uint64 token = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_token:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &token_)));
          set_has_token();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_actorid;
        break;
      }

      // optional uint64 actorid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_actorid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &actorid_)));
          set_has_actorid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterGameArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 accountid = 1;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->accountid(), output);
  }

  // optional uint64 token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->token(), output);
  }

  // optional uint64 actorid = 3;
  if (has_actorid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->actorid(), output);
  }

}

int EnterGameArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 accountid = 1;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

    // optional uint64 token = 2;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->token());
    }

    // optional uint64 actorid = 3;
    if (has_actorid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->actorid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterGameArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterGameArg*>(&from));
}

void EnterGameArg::MergeFrom(const EnterGameArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_actorid()) {
      set_actorid(from.actorid());
    }
  }
}

void EnterGameArg::CopyFrom(const EnterGameArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterGameArg::IsInitialized() const {

  return true;
}

void EnterGameArg::Swap(EnterGameArg* other) {
  if (other != this) {
    std::swap(accountid_, other->accountid_);
    std::swap(token_, other->token_);
    std::swap(actorid_, other->actorid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterGameArg::GetTypeName() const {
  return "CBR.EnterGameArg";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterGameRes::kErrorFieldNumber;
const int EnterGameRes::kActorlistFieldNumber;
#endif  // !_MSC_VER

EnterGameRes::EnterGameRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterGameRes::InitAsDefaultInstance() {
}

EnterGameRes::EnterGameRes(const EnterGameRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterGameRes::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterGameRes::~EnterGameRes() {
  SharedDtor();
}

void EnterGameRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterGameRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterGameRes& EnterGameRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

EnterGameRes* EnterGameRes::default_instance_ = NULL;

EnterGameRes* EnterGameRes::New() const {
  return new EnterGameRes;
}

void EnterGameRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_ = 0;
  }
  actorlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterGameRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_actorlist;
        break;
      }

      // repeated .CBR.ActorBase actorlist = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_actorlist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_actorlist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_actorlist;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterGameRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error(), output);
  }

  // repeated .CBR.ActorBase actorlist = 2;
  for (int i = 0; i < this->actorlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->actorlist(i), output);
  }

}

int EnterGameRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  // repeated .CBR.ActorBase actorlist = 2;
  total_size += 1 * this->actorlist_size();
  for (int i = 0; i < this->actorlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->actorlist(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterGameRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterGameRes*>(&from));
}

void EnterGameRes::MergeFrom(const EnterGameRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  actorlist_.MergeFrom(from.actorlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
  }
}

void EnterGameRes::CopyFrom(const EnterGameRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterGameRes::IsInitialized() const {

  return true;
}

void EnterGameRes::Swap(EnterGameRes* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    actorlist_.Swap(&other->actorlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterGameRes::GetTypeName() const {
  return "CBR.EnterGameRes";
}


// ===================================================================

#ifndef _MSC_VER
const int ActorDataArg::kRpcidFieldNumber;
const int ActorDataArg::kActoridFieldNumber;
const int ActorDataArg::kSessionidFieldNumber;
const int ActorDataArg::kAccountidFieldNumber;
#endif  // !_MSC_VER

ActorDataArg::ActorDataArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ActorDataArg::InitAsDefaultInstance() {
}

ActorDataArg::ActorDataArg(const ActorDataArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ActorDataArg::SharedCtor() {
  _cached_size_ = 0;
  rpcid_ = 0;
  actorid_ = GOOGLE_ULONGLONG(0);
  sessionid_ = GOOGLE_ULONGLONG(0);
  accountid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActorDataArg::~ActorDataArg() {
  SharedDtor();
}

void ActorDataArg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActorDataArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActorDataArg& ActorDataArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ActorDataArg* ActorDataArg::default_instance_ = NULL;

ActorDataArg* ActorDataArg::New() const {
  return new ActorDataArg;
}

void ActorDataArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rpcid_ = 0;
    actorid_ = GOOGLE_ULONGLONG(0);
    sessionid_ = GOOGLE_ULONGLONG(0);
    accountid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ActorDataArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 rpcid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rpcid_)));
          set_has_rpcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_actorid;
        break;
      }

      // optional uint64 actorid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_actorid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &actorid_)));
          set_has_actorid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sessionid;
        break;
      }

      // optional uint64 sessionid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sessionid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sessionid_)));
          set_has_sessionid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_accountid;
        break;
      }

      // optional uint64 accountid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accountid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ActorDataArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 rpcid = 1;
  if (has_rpcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->rpcid(), output);
  }

  // optional uint64 actorid = 2;
  if (has_actorid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->actorid(), output);
  }

  // optional uint64 sessionid = 3;
  if (has_sessionid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->sessionid(), output);
  }

  // optional uint64 accountid = 4;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->accountid(), output);
  }

}

int ActorDataArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 rpcid = 1;
    if (has_rpcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rpcid());
    }

    // optional uint64 actorid = 2;
    if (has_actorid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->actorid());
    }

    // optional uint64 sessionid = 3;
    if (has_sessionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sessionid());
    }

    // optional uint64 accountid = 4;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActorDataArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActorDataArg*>(&from));
}

void ActorDataArg::MergeFrom(const ActorDataArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rpcid()) {
      set_rpcid(from.rpcid());
    }
    if (from.has_actorid()) {
      set_actorid(from.actorid());
    }
    if (from.has_sessionid()) {
      set_sessionid(from.sessionid());
    }
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
  }
}

void ActorDataArg::CopyFrom(const ActorDataArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorDataArg::IsInitialized() const {

  return true;
}

void ActorDataArg::Swap(ActorDataArg* other) {
  if (other != this) {
    std::swap(rpcid_, other->rpcid_);
    std::swap(actorid_, other->actorid_);
    std::swap(sessionid_, other->sessionid_);
    std::swap(accountid_, other->accountid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActorDataArg::GetTypeName() const {
  return "CBR.ActorDataArg";
}


// ===================================================================

#ifndef _MSC_VER
const int ActorDataRes::kActorlistFieldNumber;
const int ActorDataRes::kErrorFieldNumber;
const int ActorDataRes::kRpcidFieldNumber;
#endif  // !_MSC_VER

ActorDataRes::ActorDataRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ActorDataRes::InitAsDefaultInstance() {
}

ActorDataRes::ActorDataRes(const ActorDataRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ActorDataRes::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  rpcid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActorDataRes::~ActorDataRes() {
  SharedDtor();
}

void ActorDataRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActorDataRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActorDataRes& ActorDataRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ActorDataRes* ActorDataRes::default_instance_ = NULL;

ActorDataRes* ActorDataRes::New() const {
  return new ActorDataRes;
}

void ActorDataRes::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    error_ = 0;
    rpcid_ = 0u;
  }
  actorlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ActorDataRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .CBR.ActorBase actorlist = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_actorlist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_actorlist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_actorlist;
        if (input->ExpectTag(16)) goto parse_error;
        break;
      }

      // optional .CBR.ErrorCode error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_rpcid;
        break;
      }

      // optional uint32 rpcid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rpcid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rpcid_)));
          set_has_rpcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ActorDataRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .CBR.ActorBase actorlist = 1;
  for (int i = 0; i < this->actorlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->actorlist(i), output);
  }

  // optional .CBR.ErrorCode error = 2;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->error(), output);
  }

  // optional uint32 rpcid = 3;
  if (has_rpcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->rpcid(), output);
  }

}

int ActorDataRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .CBR.ErrorCode error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

    // optional uint32 rpcid = 3;
    if (has_rpcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rpcid());
    }

  }
  // repeated .CBR.ActorBase actorlist = 1;
  total_size += 1 * this->actorlist_size();
  for (int i = 0; i < this->actorlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->actorlist(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActorDataRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActorDataRes*>(&from));
}

void ActorDataRes::MergeFrom(const ActorDataRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  actorlist_.MergeFrom(from.actorlist_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
    if (from.has_rpcid()) {
      set_rpcid(from.rpcid());
    }
  }
}

void ActorDataRes::CopyFrom(const ActorDataRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorDataRes::IsInitialized() const {

  return true;
}

void ActorDataRes::Swap(ActorDataRes* other) {
  if (other != this) {
    actorlist_.Swap(&other->actorlist_);
    std::swap(error_, other->error_);
    std::swap(rpcid_, other->rpcid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActorDataRes::GetTypeName() const {
  return "CBR.ActorDataRes";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateActorReq::kHairidFieldNumber;
const int CreateActorReq::kFaceidFieldNumber;
const int CreateActorReq::kSexFieldNumber;
const int CreateActorReq::kNameFieldNumber;
const int CreateActorReq::kAccountidFieldNumber;
const int CreateActorReq::kSeqindexFieldNumber;
const int CreateActorReq::kActortypeFieldNumber;
const int CreateActorReq::kResidFieldNumber;
const int CreateActorReq::kRpcidFieldNumber;
#endif  // !_MSC_VER

CreateActorReq::CreateActorReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateActorReq::InitAsDefaultInstance() {
}

CreateActorReq::CreateActorReq(const CreateActorReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateActorReq::SharedCtor() {
  _cached_size_ = 0;
  hairid_ = 0u;
  faceid_ = 0u;
  sex_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  accountid_ = GOOGLE_ULONGLONG(0);
  seqindex_ = 0u;
  actortype_ = 0u;
  resid_ = 0u;
  rpcid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateActorReq::~CreateActorReq() {
  SharedDtor();
}

void CreateActorReq::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateActorReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateActorReq& CreateActorReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

CreateActorReq* CreateActorReq::default_instance_ = NULL;

CreateActorReq* CreateActorReq::New() const {
  return new CreateActorReq;
}

void CreateActorReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    hairid_ = 0u;
    faceid_ = 0u;
    sex_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    accountid_ = GOOGLE_ULONGLONG(0);
    seqindex_ = 0u;
    actortype_ = 0u;
    resid_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    rpcid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateActorReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 hairid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hairid_)));
          set_has_hairid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_faceid;
        break;
      }

      // optional uint32 faceid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_faceid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &faceid_)));
          set_has_faceid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sex;
        break;
      }

      // optional uint32 sex = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_name;
        break;
      }

      // optional string name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_accountid;
        break;
      }

      // optional uint64 accountid = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accountid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_seqindex;
        break;
      }

      // optional uint32 seqindex = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seqindex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seqindex_)));
          set_has_seqindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_actortype;
        break;
      }

      // optional uint32 actortype = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_actortype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &actortype_)));
          set_has_actortype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_resid;
        break;
      }

      // optional uint32 resid = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_resid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &resid_)));
          set_has_resid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_rpcid;
        break;
      }

      // optional uint32 rpcid = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rpcid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rpcid_)));
          set_has_rpcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateActorReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 hairid = 1;
  if (has_hairid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->hairid(), output);
  }

  // optional uint32 faceid = 2;
  if (has_faceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->faceid(), output);
  }

  // optional uint32 sex = 3;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sex(), output);
  }

  // optional string name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->name(), output);
  }

  // optional uint64 accountid = 5;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->accountid(), output);
  }

  // optional uint32 seqindex = 6;
  if (has_seqindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->seqindex(), output);
  }

  // optional uint32 actortype = 7;
  if (has_actortype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->actortype(), output);
  }

  // optional uint32 resid = 8;
  if (has_resid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->resid(), output);
  }

  // optional uint32 rpcid = 9;
  if (has_rpcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->rpcid(), output);
  }

}

int CreateActorReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 hairid = 1;
    if (has_hairid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hairid());
    }

    // optional uint32 faceid = 2;
    if (has_faceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->faceid());
    }

    // optional uint32 sex = 3;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sex());
    }

    // optional string name = 4;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint64 accountid = 5;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

    // optional uint32 seqindex = 6;
    if (has_seqindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seqindex());
    }

    // optional uint32 actortype = 7;
    if (has_actortype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->actortype());
    }

    // optional uint32 resid = 8;
    if (has_resid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->resid());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 rpcid = 9;
    if (has_rpcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rpcid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateActorReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateActorReq*>(&from));
}

void CreateActorReq::MergeFrom(const CreateActorReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hairid()) {
      set_hairid(from.hairid());
    }
    if (from.has_faceid()) {
      set_faceid(from.faceid());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
    if (from.has_seqindex()) {
      set_seqindex(from.seqindex());
    }
    if (from.has_actortype()) {
      set_actortype(from.actortype());
    }
    if (from.has_resid()) {
      set_resid(from.resid());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_rpcid()) {
      set_rpcid(from.rpcid());
    }
  }
}

void CreateActorReq::CopyFrom(const CreateActorReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateActorReq::IsInitialized() const {

  return true;
}

void CreateActorReq::Swap(CreateActorReq* other) {
  if (other != this) {
    std::swap(hairid_, other->hairid_);
    std::swap(faceid_, other->faceid_);
    std::swap(sex_, other->sex_);
    std::swap(name_, other->name_);
    std::swap(accountid_, other->accountid_);
    std::swap(seqindex_, other->seqindex_);
    std::swap(actortype_, other->actortype_);
    std::swap(resid_, other->resid_);
    std::swap(rpcid_, other->rpcid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateActorReq::GetTypeName() const {
  return "CBR.CreateActorReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateActorRes::kResultFieldNumber;
const int CreateActorRes::kAccoutidFieldNumber;
const int CreateActorRes::kActoridFieldNumber;
#endif  // !_MSC_VER

CreateActorRes::CreateActorRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateActorRes::InitAsDefaultInstance() {
}

CreateActorRes::CreateActorRes(const CreateActorRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateActorRes::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  accoutid_ = GOOGLE_ULONGLONG(0);
  actorid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateActorRes::~CreateActorRes() {
  SharedDtor();
}

void CreateActorRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateActorRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateActorRes& CreateActorRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

CreateActorRes* CreateActorRes::default_instance_ = NULL;

CreateActorRes* CreateActorRes::New() const {
  return new CreateActorRes;
}

void CreateActorRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    accoutid_ = GOOGLE_ULONGLONG(0);
    actorid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateActorRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_result(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_accoutid;
        break;
      }

      // optional uint64 accoutid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accoutid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accoutid_)));
          set_has_accoutid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_actorid;
        break;
      }

      // optional uint64 actorid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_actorid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &actorid_)));
          set_has_actorid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateActorRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional uint64 accoutid = 2;
  if (has_accoutid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->accoutid(), output);
  }

  // optional uint64 actorid = 3;
  if (has_actorid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->actorid(), output);
  }

}

int CreateActorRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional uint64 accoutid = 2;
    if (has_accoutid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accoutid());
    }

    // optional uint64 actorid = 3;
    if (has_actorid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->actorid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateActorRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateActorRes*>(&from));
}

void CreateActorRes::MergeFrom(const CreateActorRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_accoutid()) {
      set_accoutid(from.accoutid());
    }
    if (from.has_actorid()) {
      set_actorid(from.actorid());
    }
  }
}

void CreateActorRes::CopyFrom(const CreateActorRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateActorRes::IsInitialized() const {

  return true;
}

void CreateActorRes::Swap(CreateActorRes* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(accoutid_, other->accoutid_);
    std::swap(actorid_, other->actorid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateActorRes::GetTypeName() const {
  return "CBR.CreateActorRes";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginOutData::kSessionFieldNumber;
const int LoginOutData::kErrorFieldNumber;
#endif  // !_MSC_VER

LoginOutData::LoginOutData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginOutData::InitAsDefaultInstance() {
}

LoginOutData::LoginOutData(const LoginOutData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginOutData::SharedCtor() {
  _cached_size_ = 0;
  session_ = GOOGLE_ULONGLONG(0);
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginOutData::~LoginOutData() {
  SharedDtor();
}

void LoginOutData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginOutData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginOutData& LoginOutData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

LoginOutData* LoginOutData::default_instance_ = NULL;

LoginOutData* LoginOutData::New() const {
  return new LoginOutData;
}

void LoginOutData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    session_ = GOOGLE_ULONGLONG(0);
    error_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginOutData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 session = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &session_)));
          set_has_session();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_error;
        break;
      }

      // optional .CBR.ErrorCode error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginOutData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 session = 1;
  if (has_session()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->session(), output);
  }

  // optional .CBR.ErrorCode error = 2;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->error(), output);
  }

}

int LoginOutData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 session = 1;
    if (has_session()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->session());
    }

    // optional .CBR.ErrorCode error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginOutData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginOutData*>(&from));
}

void LoginOutData::MergeFrom(const LoginOutData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session()) {
      set_session(from.session());
    }
    if (from.has_error()) {
      set_error(from.error());
    }
  }
}

void LoginOutData::CopyFrom(const LoginOutData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginOutData::IsInitialized() const {

  return true;
}

void LoginOutData::Swap(LoginOutData* other) {
  if (other != this) {
    std::swap(session_, other->session_);
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginOutData::GetTypeName() const {
  return "CBR.LoginOutData";
}


// ===================================================================

#ifndef _MSC_VER
const int UserSaveData::kAccountidFieldNumber;
const int UserSaveData::kAccountnameFieldNumber;
const int UserSaveData::kChannelFieldNumber;
const int UserSaveData::kPasswardFieldNumber;
const int UserSaveData::kIsbindFieldNumber;
const int UserSaveData::kBindaccountidFieldNumber;
const int UserSaveData::kBindtimeFieldNumber;
const int UserSaveData::kDeviceidFieldNumber;
const int UserSaveData::kIpFieldNumber;
const int UserSaveData::kRegtimeFieldNumber;
const int UserSaveData::kStateFieldNumber;
#endif  // !_MSC_VER

UserSaveData::UserSaveData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UserSaveData::InitAsDefaultInstance() {
}

UserSaveData::UserSaveData(const UserSaveData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UserSaveData::SharedCtor() {
  _cached_size_ = 0;
  accountid_ = GOOGLE_ULONGLONG(0);
  accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  channel_ = 0u;
  passward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  isbind_ = 0u;
  bindaccountid_ = GOOGLE_ULONGLONG(0);
  bindtime_ = 0u;
  deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  regtime_ = 0u;
  state_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserSaveData::~UserSaveData() {
  SharedDtor();
}

void UserSaveData::SharedDtor() {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  if (passward_ != &::google::protobuf::internal::kEmptyString) {
    delete passward_;
  }
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserSaveData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserSaveData& UserSaveData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

UserSaveData* UserSaveData::default_instance_ = NULL;

UserSaveData* UserSaveData::New() const {
  return new UserSaveData;
}

void UserSaveData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    accountid_ = GOOGLE_ULONGLONG(0);
    if (has_accountname()) {
      if (accountname_ != &::google::protobuf::internal::kEmptyString) {
        accountname_->clear();
      }
    }
    channel_ = 0u;
    if (has_passward()) {
      if (passward_ != &::google::protobuf::internal::kEmptyString) {
        passward_->clear();
      }
    }
    isbind_ = 0u;
    bindaccountid_ = GOOGLE_ULONGLONG(0);
    bindtime_ = 0u;
    if (has_deviceid()) {
      if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
        deviceid_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    regtime_ = 0u;
    state_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UserSaveData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 accountid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_accountname;
        break;
      }

      // optional string accountname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_accountname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_accountname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_channel;
        break;
      }

      // optional uint32 channel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_passward;
        break;
      }

      // optional string passward = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_passward:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_passward()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_isbind;
        break;
      }

      // optional uint32 isbind = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isbind:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &isbind_)));
          set_has_isbind();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_bindaccountid;
        break;
      }

      // optional uint64 bindaccountid = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bindaccountid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bindaccountid_)));
          set_has_bindaccountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_bindtime;
        break;
      }

      // optional uint32 bindtime = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bindtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bindtime_)));
          set_has_bindtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_deviceid;
        break;
      }

      // optional string deviceid = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_deviceid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deviceid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_ip;
        break;
      }

      // optional string ip = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_regtime;
        break;
      }

      // optional uint32 regtime = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_regtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &regtime_)));
          set_has_regtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_state;
        break;
      }

      // optional uint32 state = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserSaveData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 accountid = 1;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->accountid(), output);
  }

  // optional string accountname = 2;
  if (has_accountname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->accountname(), output);
  }

  // optional uint32 channel = 3;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->channel(), output);
  }

  // optional string passward = 4;
  if (has_passward()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->passward(), output);
  }

  // optional uint32 isbind = 5;
  if (has_isbind()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->isbind(), output);
  }

  // optional uint64 bindaccountid = 6;
  if (has_bindaccountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->bindaccountid(), output);
  }

  // optional uint32 bindtime = 7;
  if (has_bindtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->bindtime(), output);
  }

  // optional string deviceid = 8;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->deviceid(), output);
  }

  // optional string ip = 9;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->ip(), output);
  }

  // optional uint32 regtime = 10;
  if (has_regtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->regtime(), output);
  }

  // optional uint32 state = 11;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->state(), output);
  }

}

int UserSaveData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 accountid = 1;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

    // optional string accountname = 2;
    if (has_accountname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->accountname());
    }

    // optional uint32 channel = 3;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->channel());
    }

    // optional string passward = 4;
    if (has_passward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->passward());
    }

    // optional uint32 isbind = 5;
    if (has_isbind()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->isbind());
    }

    // optional uint64 bindaccountid = 6;
    if (has_bindaccountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bindaccountid());
    }

    // optional uint32 bindtime = 7;
    if (has_bindtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bindtime());
    }

    // optional string deviceid = 8;
    if (has_deviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deviceid());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string ip = 9;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional uint32 regtime = 10;
    if (has_regtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->regtime());
    }

    // optional uint32 state = 11;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserSaveData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserSaveData*>(&from));
}

void UserSaveData::MergeFrom(const UserSaveData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
    if (from.has_accountname()) {
      set_accountname(from.accountname());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_passward()) {
      set_passward(from.passward());
    }
    if (from.has_isbind()) {
      set_isbind(from.isbind());
    }
    if (from.has_bindaccountid()) {
      set_bindaccountid(from.bindaccountid());
    }
    if (from.has_bindtime()) {
      set_bindtime(from.bindtime());
    }
    if (from.has_deviceid()) {
      set_deviceid(from.deviceid());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_regtime()) {
      set_regtime(from.regtime());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
}

void UserSaveData::CopyFrom(const UserSaveData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserSaveData::IsInitialized() const {

  return true;
}

void UserSaveData::Swap(UserSaveData* other) {
  if (other != this) {
    std::swap(accountid_, other->accountid_);
    std::swap(accountname_, other->accountname_);
    std::swap(channel_, other->channel_);
    std::swap(passward_, other->passward_);
    std::swap(isbind_, other->isbind_);
    std::swap(bindaccountid_, other->bindaccountid_);
    std::swap(bindtime_, other->bindtime_);
    std::swap(deviceid_, other->deviceid_);
    std::swap(ip_, other->ip_);
    std::swap(regtime_, other->regtime_);
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserSaveData::GetTypeName() const {
  return "CBR.UserSaveData";
}


// ===================================================================

#ifndef _MSC_VER
const int ActorInfo::kActorFieldNumber;
#endif  // !_MSC_VER

ActorInfo::ActorInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ActorInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  actor_ = const_cast< ::CBR::ActorBase*>(
      ::CBR::ActorBase::internal_default_instance());
#else
  actor_ = const_cast< ::CBR::ActorBase*>(&::CBR::ActorBase::default_instance());
#endif
}

ActorInfo::ActorInfo(const ActorInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ActorInfo::SharedCtor() {
  _cached_size_ = 0;
  actor_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActorInfo::~ActorInfo() {
  SharedDtor();
}

void ActorInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete actor_;
  }
}

void ActorInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActorInfo& ActorInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ActorInfo* ActorInfo::default_instance_ = NULL;

ActorInfo* ActorInfo::New() const {
  return new ActorInfo;
}

void ActorInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_actor()) {
      if (actor_ != NULL) actor_->::CBR::ActorBase::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ActorInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ActorBase actor = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ActorInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ActorBase actor = 1;
  if (has_actor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->actor(), output);
  }

}

int ActorInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ActorBase actor = 1;
    if (has_actor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->actor());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActorInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActorInfo*>(&from));
}

void ActorInfo::MergeFrom(const ActorInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_actor()) {
      mutable_actor()->::CBR::ActorBase::MergeFrom(from.actor());
    }
  }
}

void ActorInfo::CopyFrom(const ActorInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorInfo::IsInitialized() const {

  return true;
}

void ActorInfo::Swap(ActorInfo* other) {
  if (other != this) {
    std::swap(actor_, other->actor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActorInfo::GetTypeName() const {
  return "CBR.ActorInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ActorBrief::kIdFieldNumber;
const int ActorBrief::kNameFieldNumber;
#endif  // !_MSC_VER

ActorBrief::ActorBrief()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ActorBrief::InitAsDefaultInstance() {
}

ActorBrief::ActorBrief(const ActorBrief& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ActorBrief::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActorBrief::~ActorBrief() {
  SharedDtor();
}

void ActorBrief::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActorBrief::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActorBrief& ActorBrief::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ActorBrief* ActorBrief::default_instance_ = NULL;

ActorBrief* ActorBrief::New() const {
  return new ActorBrief;
}

void ActorBrief::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ActorBrief::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ActorBrief::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

}

int ActorBrief::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActorBrief::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActorBrief*>(&from));
}

void ActorBrief::MergeFrom(const ActorBrief& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void ActorBrief::CopyFrom(const ActorBrief& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorBrief::IsInitialized() const {

  return true;
}

void ActorBrief::Swap(ActorBrief* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActorBrief::GetTypeName() const {
  return "CBR.ActorBrief";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateActorDataArg::kActFieldNumber;
#endif  // !_MSC_VER

UpdateActorDataArg::UpdateActorDataArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateActorDataArg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  act_ = const_cast< ::CBR::ActorBase*>(
      ::CBR::ActorBase::internal_default_instance());
#else
  act_ = const_cast< ::CBR::ActorBase*>(&::CBR::ActorBase::default_instance());
#endif
}

UpdateActorDataArg::UpdateActorDataArg(const UpdateActorDataArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateActorDataArg::SharedCtor() {
  _cached_size_ = 0;
  act_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateActorDataArg::~UpdateActorDataArg() {
  SharedDtor();
}

void UpdateActorDataArg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete act_;
  }
}

void UpdateActorDataArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateActorDataArg& UpdateActorDataArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

UpdateActorDataArg* UpdateActorDataArg::default_instance_ = NULL;

UpdateActorDataArg* UpdateActorDataArg::New() const {
  return new UpdateActorDataArg;
}

void UpdateActorDataArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_act()) {
      if (act_ != NULL) act_->::CBR::ActorBase::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateActorDataArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ActorBase act = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_act()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateActorDataArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ActorBase act = 1;
  if (has_act()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->act(), output);
  }

}

int UpdateActorDataArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ActorBase act = 1;
    if (has_act()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->act());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateActorDataArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateActorDataArg*>(&from));
}

void UpdateActorDataArg::MergeFrom(const UpdateActorDataArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_act()) {
      mutable_act()->::CBR::ActorBase::MergeFrom(from.act());
    }
  }
}

void UpdateActorDataArg::CopyFrom(const UpdateActorDataArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateActorDataArg::IsInitialized() const {

  return true;
}

void UpdateActorDataArg::Swap(UpdateActorDataArg* other) {
  if (other != this) {
    std::swap(act_, other->act_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateActorDataArg::GetTypeName() const {
  return "CBR.UpdateActorDataArg";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateActorDataRes::kErrorFieldNumber;
#endif  // !_MSC_VER

UpdateActorDataRes::UpdateActorDataRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateActorDataRes::InitAsDefaultInstance() {
}

UpdateActorDataRes::UpdateActorDataRes(const UpdateActorDataRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateActorDataRes::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateActorDataRes::~UpdateActorDataRes() {
  SharedDtor();
}

void UpdateActorDataRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateActorDataRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateActorDataRes& UpdateActorDataRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

UpdateActorDataRes* UpdateActorDataRes::default_instance_ = NULL;

UpdateActorDataRes* UpdateActorDataRes::New() const {
  return new UpdateActorDataRes;
}

void UpdateActorDataRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateActorDataRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateActorDataRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error(), output);
  }

}

int UpdateActorDataRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateActorDataRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateActorDataRes*>(&from));
}

void UpdateActorDataRes::MergeFrom(const UpdateActorDataRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
  }
}

void UpdateActorDataRes::CopyFrom(const UpdateActorDataRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateActorDataRes::IsInitialized() const {

  return true;
}

void UpdateActorDataRes::Swap(UpdateActorDataRes* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateActorDataRes::GetTypeName() const {
  return "CBR.UpdateActorDataRes";
}


// ===================================================================

#ifndef _MSC_VER
const int ClientAuthArg::kTokenFieldNumber;
const int ClientAuthArg::kUseridFieldNumber;
#endif  // !_MSC_VER

ClientAuthArg::ClientAuthArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ClientAuthArg::InitAsDefaultInstance() {
}

ClientAuthArg::ClientAuthArg(const ClientAuthArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ClientAuthArg::SharedCtor() {
  _cached_size_ = 0;
  token_ = GOOGLE_ULONGLONG(0);
  userid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientAuthArg::~ClientAuthArg() {
  SharedDtor();
}

void ClientAuthArg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClientAuthArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientAuthArg& ClientAuthArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ClientAuthArg* ClientAuthArg::default_instance_ = NULL;

ClientAuthArg* ClientAuthArg::New() const {
  return new ClientAuthArg;
}

void ClientAuthArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    token_ = GOOGLE_ULONGLONG(0);
    userid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClientAuthArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 token = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &token_)));
          set_has_token();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_userid;
        break;
      }

      // optional uint64 userid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_userid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientAuthArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->token(), output);
  }

  // optional uint64 userid = 2;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->userid(), output);
  }

}

int ClientAuthArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 token = 1;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->token());
    }

    // optional uint64 userid = 2;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->userid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientAuthArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientAuthArg*>(&from));
}

void ClientAuthArg::MergeFrom(const ClientAuthArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
}

void ClientAuthArg::CopyFrom(const ClientAuthArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientAuthArg::IsInitialized() const {

  return true;
}

void ClientAuthArg::Swap(ClientAuthArg* other) {
  if (other != this) {
    std::swap(token_, other->token_);
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ClientAuthArg::GetTypeName() const {
  return "CBR.ClientAuthArg";
}


// ===================================================================

#ifndef _MSC_VER
const int ClientAuthRes::kRetFieldNumber;
#endif  // !_MSC_VER

ClientAuthRes::ClientAuthRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ClientAuthRes::InitAsDefaultInstance() {
}

ClientAuthRes::ClientAuthRes(const ClientAuthRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ClientAuthRes::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientAuthRes::~ClientAuthRes() {
  SharedDtor();
}

void ClientAuthRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClientAuthRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientAuthRes& ClientAuthRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

ClientAuthRes* ClientAuthRes::default_instance_ = NULL;

ClientAuthRes* ClientAuthRes::New() const {
  return new ClientAuthRes;
}

void ClientAuthRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ClientAuthRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_ret(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientAuthRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->ret(), output);
  }

}

int ClientAuthRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ret());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientAuthRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientAuthRes*>(&from));
}

void ClientAuthRes::MergeFrom(const ClientAuthRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
}

void ClientAuthRes::CopyFrom(const ClientAuthRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientAuthRes::IsInitialized() const {

  return true;
}

void ClientAuthRes::Swap(ClientAuthRes* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ClientAuthRes::GetTypeName() const {
  return "CBR.ClientAuthRes";
}


// ===================================================================

#ifndef _MSC_VER
const int HeartbeatData::kTimeFieldNumber;
#endif  // !_MSC_VER

HeartbeatData::HeartbeatData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HeartbeatData::InitAsDefaultInstance() {
}

HeartbeatData::HeartbeatData(const HeartbeatData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HeartbeatData::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatData::~HeartbeatData() {
  SharedDtor();
}

void HeartbeatData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HeartbeatData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HeartbeatData& HeartbeatData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

HeartbeatData* HeartbeatData::default_instance_ = NULL;

HeartbeatData* HeartbeatData::New() const {
  return new HeartbeatData;
}

void HeartbeatData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HeartbeatData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeartbeatData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time(), output);
  }

}

int HeartbeatData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 time = 1;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HeartbeatData*>(&from));
}

void HeartbeatData::MergeFrom(const HeartbeatData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void HeartbeatData::CopyFrom(const HeartbeatData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatData::IsInitialized() const {

  return true;
}

void HeartbeatData::Swap(HeartbeatData* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HeartbeatData::GetTypeName() const {
  return "CBR.HeartbeatData";
}


// ===================================================================

#ifndef _MSC_VER
const int Friend2Db::kActoridFieldNumber;
#endif  // !_MSC_VER

Friend2Db::Friend2Db()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Friend2Db::InitAsDefaultInstance() {
}

Friend2Db::Friend2Db(const Friend2Db& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Friend2Db::SharedCtor() {
  _cached_size_ = 0;
  actorid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Friend2Db::~Friend2Db() {
  SharedDtor();
}

void Friend2Db::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Friend2Db::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Friend2Db& Friend2Db::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

Friend2Db* Friend2Db::default_instance_ = NULL;

Friend2Db* Friend2Db::New() const {
  return new Friend2Db;
}

void Friend2Db::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    actorid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Friend2Db::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 actorid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &actorid_)));
          set_has_actorid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Friend2Db::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 actorid = 1;
  if (has_actorid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->actorid(), output);
  }

}

int Friend2Db::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 actorid = 1;
    if (has_actorid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->actorid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Friend2Db::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Friend2Db*>(&from));
}

void Friend2Db::MergeFrom(const Friend2Db& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_actorid()) {
      set_actorid(from.actorid());
    }
  }
}

void Friend2Db::CopyFrom(const Friend2Db& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Friend2Db::IsInitialized() const {

  return true;
}

void Friend2Db::Swap(Friend2Db* other) {
  if (other != this) {
    std::swap(actorid_, other->actorid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Friend2Db::GetTypeName() const {
  return "CBR.Friend2Db";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterHallToDcmArg::kServeridFieldNumber;
const int RegisterHallToDcmArg::kIpFieldNumber;
const int RegisterHallToDcmArg::kPortFieldNumber;
const int RegisterHallToDcmArg::kNameFieldNumber;
#endif  // !_MSC_VER

RegisterHallToDcmArg::RegisterHallToDcmArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterHallToDcmArg::InitAsDefaultInstance() {
}

RegisterHallToDcmArg::RegisterHallToDcmArg(const RegisterHallToDcmArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterHallToDcmArg::SharedCtor() {
  _cached_size_ = 0;
  serverid_ = 0u;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterHallToDcmArg::~RegisterHallToDcmArg() {
  SharedDtor();
}

void RegisterHallToDcmArg::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterHallToDcmArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterHallToDcmArg& RegisterHallToDcmArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegisterHallToDcmArg* RegisterHallToDcmArg::default_instance_ = NULL;

RegisterHallToDcmArg* RegisterHallToDcmArg::New() const {
  return new RegisterHallToDcmArg;
}

void RegisterHallToDcmArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    serverid_ = 0u;
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterHallToDcmArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 serverid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serverid_)));
          set_has_serverid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ip;
        break;
      }

      // optional string ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // optional uint32 port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_name;
        break;
      }

      // optional string name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterHallToDcmArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 serverid = 1;
  if (has_serverid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serverid(), output);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->ip(), output);
  }

  // optional uint32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // optional string name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->name(), output);
  }

}

int RegisterHallToDcmArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 serverid = 1;
    if (has_serverid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serverid());
    }

    // optional string ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional uint32 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // optional string name = 4;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterHallToDcmArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterHallToDcmArg*>(&from));
}

void RegisterHallToDcmArg::MergeFrom(const RegisterHallToDcmArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serverid()) {
      set_serverid(from.serverid());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void RegisterHallToDcmArg::CopyFrom(const RegisterHallToDcmArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterHallToDcmArg::IsInitialized() const {

  return true;
}

void RegisterHallToDcmArg::Swap(RegisterHallToDcmArg* other) {
  if (other != this) {
    std::swap(serverid_, other->serverid_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterHallToDcmArg::GetTypeName() const {
  return "CBR.RegisterHallToDcmArg";
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterHallToDcmRes::kErrorFieldNumber;
#endif  // !_MSC_VER

RegisterHallToDcmRes::RegisterHallToDcmRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RegisterHallToDcmRes::InitAsDefaultInstance() {
}

RegisterHallToDcmRes::RegisterHallToDcmRes(const RegisterHallToDcmRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterHallToDcmRes::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterHallToDcmRes::~RegisterHallToDcmRes() {
  SharedDtor();
}

void RegisterHallToDcmRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterHallToDcmRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterHallToDcmRes& RegisterHallToDcmRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RegisterHallToDcmRes* RegisterHallToDcmRes::default_instance_ = NULL;

RegisterHallToDcmRes* RegisterHallToDcmRes::New() const {
  return new RegisterHallToDcmRes;
}

void RegisterHallToDcmRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RegisterHallToDcmRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterHallToDcmRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error(), output);
  }

}

int RegisterHallToDcmRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterHallToDcmRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterHallToDcmRes*>(&from));
}

void RegisterHallToDcmRes::MergeFrom(const RegisterHallToDcmRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
  }
}

void RegisterHallToDcmRes::CopyFrom(const RegisterHallToDcmRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterHallToDcmRes::IsInitialized() const {

  return true;
}

void RegisterHallToDcmRes::Swap(RegisterHallToDcmRes* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RegisterHallToDcmRes::GetTypeName() const {
  return "CBR.RegisterHallToDcmRes";
}


// ===================================================================

#ifndef _MSC_VER
const int StartMatchArg::kAccountidFieldNumber;
const int StartMatchArg::kAccountnameFieldNumber;
const int StartMatchArg::kTeamidFieldNumber;
const int StartMatchArg::kMatchtypeFieldNumber;
#endif  // !_MSC_VER

StartMatchArg::StartMatchArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartMatchArg::InitAsDefaultInstance() {
}

StartMatchArg::StartMatchArg(const StartMatchArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartMatchArg::SharedCtor() {
  _cached_size_ = 0;
  accountid_ = GOOGLE_ULONGLONG(0);
  accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  teamid_ = 0u;
  matchtype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartMatchArg::~StartMatchArg() {
  SharedDtor();
}

void StartMatchArg::SharedDtor() {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartMatchArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartMatchArg& StartMatchArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

StartMatchArg* StartMatchArg::default_instance_ = NULL;

StartMatchArg* StartMatchArg::New() const {
  return new StartMatchArg;
}

void StartMatchArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    accountid_ = GOOGLE_ULONGLONG(0);
    if (has_accountname()) {
      if (accountname_ != &::google::protobuf::internal::kEmptyString) {
        accountname_->clear();
      }
    }
    teamid_ = 0u;
    matchtype_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartMatchArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 accountid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_accountname;
        break;
      }

      // optional string accountname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_accountname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_accountname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_teamid;
        break;
      }

      // optional uint32 teamid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_teamid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &teamid_)));
          set_has_teamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_matchtype;
        break;
      }

      // optional .CBR.ENUM_MATCH_TYPE matchtype = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_matchtype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ENUM_MATCH_TYPE_IsValid(value)) {
            set_matchtype(static_cast< ::CBR::ENUM_MATCH_TYPE >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartMatchArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 accountid = 1;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->accountid(), output);
  }

  // optional string accountname = 2;
  if (has_accountname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->accountname(), output);
  }

  // optional uint32 teamid = 3;
  if (has_teamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->teamid(), output);
  }

  // optional .CBR.ENUM_MATCH_TYPE matchtype = 4;
  if (has_matchtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->matchtype(), output);
  }

}

int StartMatchArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 accountid = 1;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

    // optional string accountname = 2;
    if (has_accountname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->accountname());
    }

    // optional uint32 teamid = 3;
    if (has_teamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->teamid());
    }

    // optional .CBR.ENUM_MATCH_TYPE matchtype = 4;
    if (has_matchtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->matchtype());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartMatchArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartMatchArg*>(&from));
}

void StartMatchArg::MergeFrom(const StartMatchArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
    if (from.has_accountname()) {
      set_accountname(from.accountname());
    }
    if (from.has_teamid()) {
      set_teamid(from.teamid());
    }
    if (from.has_matchtype()) {
      set_matchtype(from.matchtype());
    }
  }
}

void StartMatchArg::CopyFrom(const StartMatchArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartMatchArg::IsInitialized() const {

  return true;
}

void StartMatchArg::Swap(StartMatchArg* other) {
  if (other != this) {
    std::swap(accountid_, other->accountid_);
    std::swap(accountname_, other->accountname_);
    std::swap(teamid_, other->teamid_);
    std::swap(matchtype_, other->matchtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartMatchArg::GetTypeName() const {
  return "CBR.StartMatchArg";
}


// ===================================================================

#ifndef _MSC_VER
const int StartMatchRes::kErrorFieldNumber;
#endif  // !_MSC_VER

StartMatchRes::StartMatchRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartMatchRes::InitAsDefaultInstance() {
}

StartMatchRes::StartMatchRes(const StartMatchRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartMatchRes::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartMatchRes::~StartMatchRes() {
  SharedDtor();
}

void StartMatchRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartMatchRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartMatchRes& StartMatchRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

StartMatchRes* StartMatchRes::default_instance_ = NULL;

StartMatchRes* StartMatchRes::New() const {
  return new StartMatchRes;
}

void StartMatchRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartMatchRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CBR.ErrorCode error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CBR::ErrorCode_IsValid(value)) {
            set_error(static_cast< ::CBR::ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartMatchRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CBR.ErrorCode error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->error(), output);
  }

}

int StartMatchRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CBR.ErrorCode error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartMatchRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartMatchRes*>(&from));
}

void StartMatchRes::MergeFrom(const StartMatchRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
  }
}

void StartMatchRes::CopyFrom(const StartMatchRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartMatchRes::IsInitialized() const {

  return true;
}

void StartMatchRes::Swap(StartMatchRes* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartMatchRes::GetTypeName() const {
  return "CBR.StartMatchRes";
}


// ===================================================================

#ifndef _MSC_VER
const int MatchPlayer::kAccountIdFieldNumber;
const int MatchPlayer::kNameFieldNumber;
const int MatchPlayer::kTeamIdFieldNumber;
const int MatchPlayer::kHeroIdFieldNumber;
const int MatchPlayer::kGradeFieldNumber;
#endif  // !_MSC_VER

MatchPlayer::MatchPlayer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MatchPlayer::InitAsDefaultInstance() {
}

MatchPlayer::MatchPlayer(const MatchPlayer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MatchPlayer::SharedCtor() {
  _cached_size_ = 0;
  accountid_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  teamid_ = 0u;
  heroid_ = 0u;
  grade_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchPlayer::~MatchPlayer() {
  SharedDtor();
}

void MatchPlayer::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MatchPlayer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MatchPlayer& MatchPlayer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

MatchPlayer* MatchPlayer::default_instance_ = NULL;

MatchPlayer* MatchPlayer::New() const {
  return new MatchPlayer;
}

void MatchPlayer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    accountid_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    teamid_ = 0u;
    heroid_ = 0u;
    grade_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MatchPlayer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 AccountId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // optional string Name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_TeamId;
        break;
      }

      // optional uint32 TeamId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TeamId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &teamid_)));
          set_has_teamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_HeroId;
        break;
      }

      // optional uint32 HeroId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_HeroId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heroid_)));
          set_has_heroid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Grade;
        break;
      }

      // optional uint32 Grade = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Grade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &grade_)));
          set_has_grade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MatchPlayer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 AccountId = 1;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->accountid(), output);
  }

  // optional string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional uint32 TeamId = 3;
  if (has_teamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->teamid(), output);
  }

  // optional uint32 HeroId = 4;
  if (has_heroid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->heroid(), output);
  }

  // optional uint32 Grade = 5;
  if (has_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->grade(), output);
  }

}

int MatchPlayer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 AccountId = 1;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->accountid());
    }

    // optional string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 TeamId = 3;
    if (has_teamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->teamid());
    }

    // optional uint32 HeroId = 4;
    if (has_heroid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heroid());
    }

    // optional uint32 Grade = 5;
    if (has_grade()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->grade());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchPlayer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MatchPlayer*>(&from));
}

void MatchPlayer::MergeFrom(const MatchPlayer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_teamid()) {
      set_teamid(from.teamid());
    }
    if (from.has_heroid()) {
      set_heroid(from.heroid());
    }
    if (from.has_grade()) {
      set_grade(from.grade());
    }
  }
}

void MatchPlayer::CopyFrom(const MatchPlayer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchPlayer::IsInitialized() const {

  return true;
}

void MatchPlayer::Swap(MatchPlayer* other) {
  if (other != this) {
    std::swap(accountid_, other->accountid_);
    std::swap(name_, other->name_);
    std::swap(teamid_, other->teamid_);
    std::swap(heroid_, other->heroid_);
    std::swap(grade_, other->grade_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MatchPlayer::GetTypeName() const {
  return "CBR.MatchPlayer";
}


// ===================================================================

#ifndef _MSC_VER
const int MatchResult::kAccountIdFieldNumber;
const int MatchResult::kNameFieldNumber;
const int MatchResult::kTeamIdFieldNumber;
const int MatchResult::kHeroIdFieldNumber;
const int MatchResult::kGameTimeFieldNumber;
const int MatchResult::kKillCountFieldNumber;
const int MatchResult::kDamageCountFieldNumber;
const int MatchResult::kRescueCountFieldNumber;
const int MatchResult::kReviveCountFieldNumber;
const int MatchResult::kAssistCountFieldNumber;
const int MatchResult::kRespawnCountFieldNumber;
const int MatchResult::kGradeFieldNumber;
const int MatchResult::kExpFieldNumber;
#endif  // !_MSC_VER

MatchResult::MatchResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MatchResult::InitAsDefaultInstance() {
}

MatchResult::MatchResult(const MatchResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MatchResult::SharedCtor() {
  _cached_size_ = 0;
  accountid_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  teamid_ = 0u;
  heroid_ = 0u;
  gametime_ = 0u;
  killcount_ = 0u;
  damagecount_ = 0u;
  rescuecount_ = 0u;
  revivecount_ = 0u;
  assistcount_ = 0u;
  respawncount_ = 0u;
  grade_ = 0u;
  exp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchResult::~MatchResult() {
  SharedDtor();
}

void MatchResult::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MatchResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MatchResult& MatchResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

MatchResult* MatchResult::default_instance_ = NULL;

MatchResult* MatchResult::New() const {
  return new MatchResult;
}

void MatchResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    accountid_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    teamid_ = 0u;
    heroid_ = 0u;
    gametime_ = 0u;
    killcount_ = 0u;
    damagecount_ = 0u;
    rescuecount_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    revivecount_ = 0u;
    assistcount_ = 0u;
    respawncount_ = 0u;
    grade_ = 0u;
    exp_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MatchResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 AccountId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &accountid_)));
          set_has_accountid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Name;
        break;
      }

      // optional string Name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_TeamId;
        break;
      }

      // optional uint32 TeamId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TeamId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &teamid_)));
          set_has_teamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_HeroId;
        break;
      }

      // optional uint32 HeroId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_HeroId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heroid_)));
          set_has_heroid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_GameTime;
        break;
      }

      // optional uint32 GameTime = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_GameTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gametime_)));
          set_has_gametime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_KillCount;
        break;
      }

      // optional uint32 KillCount = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_KillCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &killcount_)));
          set_has_killcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_DamageCount;
        break;
      }

      // optional uint32 DamageCount = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DamageCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &damagecount_)));
          set_has_damagecount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_RescueCount;
        break;
      }

      // optional uint32 RescueCount = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RescueCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rescuecount_)));
          set_has_rescuecount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_ReviveCount;
        break;
      }

      // optional uint32 ReviveCount = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ReviveCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &revivecount_)));
          set_has_revivecount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_AssistCount;
        break;
      }

      // optional uint32 AssistCount = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_AssistCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &assistcount_)));
          set_has_assistcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_RespawnCount;
        break;
      }

      // optional uint32 RespawnCount = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RespawnCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &respawncount_)));
          set_has_respawncount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_Grade;
        break;
      }

      // optional uint32 Grade = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Grade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &grade_)));
          set_has_grade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_Exp;
        break;
      }

      // optional uint32 Exp = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MatchResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 AccountId = 1;
  if (has_accountid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->accountid(), output);
  }

  // optional string Name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional uint32 TeamId = 3;
  if (has_teamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->teamid(), output);
  }

  // optional uint32 HeroId = 4;
  if (has_heroid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->heroid(), output);
  }

  // optional uint32 GameTime = 5;
  if (has_gametime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->gametime(), output);
  }

  // optional uint32 KillCount = 6;
  if (has_killcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->killcount(), output);
  }

  // optional uint32 DamageCount = 7;
  if (has_damagecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->damagecount(), output);
  }

  // optional uint32 RescueCount = 8;
  if (has_rescuecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->rescuecount(), output);
  }

  // optional uint32 ReviveCount = 9;
  if (has_revivecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->revivecount(), output);
  }

  // optional uint32 AssistCount = 10;
  if (has_assistcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->assistcount(), output);
  }

  // optional uint32 RespawnCount = 11;
  if (has_respawncount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->respawncount(), output);
  }

  // optional uint32 Grade = 12;
  if (has_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->grade(), output);
  }

  // optional uint32 Exp = 13;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->exp(), output);
  }

}

int MatchResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 AccountId = 1;
    if (has_accountid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->accountid());
    }

    // optional string Name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 TeamId = 3;
    if (has_teamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->teamid());
    }

    // optional uint32 HeroId = 4;
    if (has_heroid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heroid());
    }

    // optional uint32 GameTime = 5;
    if (has_gametime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gametime());
    }

    // optional uint32 KillCount = 6;
    if (has_killcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->killcount());
    }

    // optional uint32 DamageCount = 7;
    if (has_damagecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->damagecount());
    }

    // optional uint32 RescueCount = 8;
    if (has_rescuecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rescuecount());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 ReviveCount = 9;
    if (has_revivecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->revivecount());
    }

    // optional uint32 AssistCount = 10;
    if (has_assistcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->assistcount());
    }

    // optional uint32 RespawnCount = 11;
    if (has_respawncount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->respawncount());
    }

    // optional uint32 Grade = 12;
    if (has_grade()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->grade());
    }

    // optional uint32 Exp = 13;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->exp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MatchResult*>(&from));
}

void MatchResult::MergeFrom(const MatchResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accountid()) {
      set_accountid(from.accountid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_teamid()) {
      set_teamid(from.teamid());
    }
    if (from.has_heroid()) {
      set_heroid(from.heroid());
    }
    if (from.has_gametime()) {
      set_gametime(from.gametime());
    }
    if (from.has_killcount()) {
      set_killcount(from.killcount());
    }
    if (from.has_damagecount()) {
      set_damagecount(from.damagecount());
    }
    if (from.has_rescuecount()) {
      set_rescuecount(from.rescuecount());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_revivecount()) {
      set_revivecount(from.revivecount());
    }
    if (from.has_assistcount()) {
      set_assistcount(from.assistcount());
    }
    if (from.has_respawncount()) {
      set_respawncount(from.respawncount());
    }
    if (from.has_grade()) {
      set_grade(from.grade());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
  }
}

void MatchResult::CopyFrom(const MatchResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchResult::IsInitialized() const {

  return true;
}

void MatchResult::Swap(MatchResult* other) {
  if (other != this) {
    std::swap(accountid_, other->accountid_);
    std::swap(name_, other->name_);
    std::swap(teamid_, other->teamid_);
    std::swap(heroid_, other->heroid_);
    std::swap(gametime_, other->gametime_);
    std::swap(killcount_, other->killcount_);
    std::swap(damagecount_, other->damagecount_);
    std::swap(rescuecount_, other->rescuecount_);
    std::swap(revivecount_, other->revivecount_);
    std::swap(assistcount_, other->assistcount_);
    std::swap(respawncount_, other->respawncount_);
    std::swap(grade_, other->grade_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MatchResult::GetTypeName() const {
  return "CBR.MatchResult";
}


// ===================================================================

#ifndef _MSC_VER
const int MatchRobot::kRobotIdFieldNumber;
const int MatchRobot::kRobotNameFieldNumber;
const int MatchRobot::kTeamIdFieldNumber;
const int MatchRobot::kHeroIdFieldNumber;
const int MatchRobot::kLevelIdFieldNumber;
#endif  // !_MSC_VER

MatchRobot::MatchRobot()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MatchRobot::InitAsDefaultInstance() {
}

MatchRobot::MatchRobot(const MatchRobot& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MatchRobot::SharedCtor() {
  _cached_size_ = 0;
  robotid_ = 0u;
  robotname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  teamid_ = 0u;
  heroid_ = 0u;
  levelid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatchRobot::~MatchRobot() {
  SharedDtor();
}

void MatchRobot::SharedDtor() {
  if (robotname_ != &::google::protobuf::internal::kEmptyString) {
    delete robotname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MatchRobot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MatchRobot& MatchRobot::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

MatchRobot* MatchRobot::default_instance_ = NULL;

MatchRobot* MatchRobot::New() const {
  return new MatchRobot;
}

void MatchRobot::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    robotid_ = 0u;
    if (has_robotname()) {
      if (robotname_ != &::google::protobuf::internal::kEmptyString) {
        robotname_->clear();
      }
    }
    teamid_ = 0u;
    heroid_ = 0u;
    levelid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MatchRobot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 RobotId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &robotid_)));
          set_has_robotid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_RobotName;
        break;
      }

      // optional string RobotName = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_RobotName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_robotname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_TeamId;
        break;
      }

      // optional uint32 TeamId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TeamId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &teamid_)));
          set_has_teamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_HeroId;
        break;
      }

      // optional uint32 HeroId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_HeroId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heroid_)));
          set_has_heroid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_LevelId;
        break;
      }

      // optional uint32 LevelId = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_LevelId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &levelid_)));
          set_has_levelid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MatchRobot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 RobotId = 1;
  if (has_robotid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->robotid(), output);
  }

  // optional string RobotName = 2;
  if (has_robotname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->robotname(), output);
  }

  // optional uint32 TeamId = 3;
  if (has_teamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->teamid(), output);
  }

  // optional uint32 HeroId = 4;
  if (has_heroid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->heroid(), output);
  }

  // optional uint32 LevelId = 5;
  if (has_levelid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->levelid(), output);
  }

}

int MatchRobot::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 RobotId = 1;
    if (has_robotid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->robotid());
    }

    // optional string RobotName = 2;
    if (has_robotname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->robotname());
    }

    // optional uint32 TeamId = 3;
    if (has_teamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->teamid());
    }

    // optional uint32 HeroId = 4;
    if (has_heroid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heroid());
    }

    // optional uint32 LevelId = 5;
    if (has_levelid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->levelid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatchRobot::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MatchRobot*>(&from));
}

void MatchRobot::MergeFrom(const MatchRobot& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_robotid()) {
      set_robotid(from.robotid());
    }
    if (from.has_robotname()) {
      set_robotname(from.robotname());
    }
    if (from.has_teamid()) {
      set_teamid(from.teamid());
    }
    if (from.has_heroid()) {
      set_heroid(from.heroid());
    }
    if (from.has_levelid()) {
      set_levelid(from.levelid());
    }
  }
}

void MatchRobot::CopyFrom(const MatchRobot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatchRobot::IsInitialized() const {

  return true;
}

void MatchRobot::Swap(MatchRobot* other) {
  if (other != this) {
    std::swap(robotid_, other->robotid_);
    std::swap(robotname_, other->robotname_);
    std::swap(teamid_, other->teamid_);
    std::swap(heroid_, other->heroid_);
    std::swap(levelid_, other->levelid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MatchRobot::GetTypeName() const {
  return "CBR.MatchRobot";
}


// ===================================================================

#ifndef _MSC_VER
const int RoomInfo::kRoomIDFieldNumber;
const int RoomInfo::kMapIdFieldNumber;
const int RoomInfo::kPlayersFieldNumber;
const int RoomInfo::kRobotsFieldNumber;
#endif  // !_MSC_VER

RoomInfo::RoomInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoomInfo::InitAsDefaultInstance() {
}

RoomInfo::RoomInfo(const RoomInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoomInfo::SharedCtor() {
  _cached_size_ = 0;
  roomid_ = 0u;
  mapid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoomInfo::~RoomInfo() {
  SharedDtor();
}

void RoomInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RoomInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoomInfo& RoomInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

RoomInfo* RoomInfo::default_instance_ = NULL;

RoomInfo* RoomInfo::New() const {
  return new RoomInfo;
}

void RoomInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roomid_ = 0u;
    mapid_ = 0u;
  }
  players_.Clear();
  robots_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoomInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 RoomID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_MapId;
        break;
      }

      // optional uint32 MapId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_MapId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_players;
        break;
      }

      // repeated .CBR.MatchPlayer players = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_players:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_players()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_players;
        if (input->ExpectTag(34)) goto parse_robots;
        break;
      }

      // repeated .CBR.MatchRobot robots = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_robots:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_robots()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_robots;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoomInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 RoomID = 1;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->roomid(), output);
  }

  // optional uint32 MapId = 2;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->mapid(), output);
  }

  // repeated .CBR.MatchPlayer players = 3;
  for (int i = 0; i < this->players_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->players(i), output);
  }

  // repeated .CBR.MatchRobot robots = 4;
  for (int i = 0; i < this->robots_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->robots(i), output);
  }

}

int RoomInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 RoomID = 1;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roomid());
    }

    // optional uint32 MapId = 2;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mapid());
    }

  }
  // repeated .CBR.MatchPlayer players = 3;
  total_size += 1 * this->players_size();
  for (int i = 0; i < this->players_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->players(i));
  }

  // repeated .CBR.MatchRobot robots = 4;
  total_size += 1 * this->robots_size();
  for (int i = 0; i < this->robots_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->robots(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoomInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoomInfo*>(&from));
}

void RoomInfo::MergeFrom(const RoomInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  players_.MergeFrom(from.players_);
  robots_.MergeFrom(from.robots_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
  }
}

void RoomInfo::CopyFrom(const RoomInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoomInfo::IsInitialized() const {

  return true;
}

void RoomInfo::Swap(RoomInfo* other) {
  if (other != this) {
    std::swap(roomid_, other->roomid_);
    std::swap(mapid_, other->mapid_);
    players_.Swap(&other->players_);
    robots_.Swap(&other->robots_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoomInfo::GetTypeName() const {
  return "CBR.RoomInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CancelMatchArg::kParamsFieldNumber;
#endif  // !_MSC_VER

CancelMatchArg::CancelMatchArg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CancelMatchArg::InitAsDefaultInstance() {
}

CancelMatchArg::CancelMatchArg(const CancelMatchArg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CancelMatchArg::SharedCtor() {
  _cached_size_ = 0;
  params_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CancelMatchArg::~CancelMatchArg() {
  SharedDtor();
}

void CancelMatchArg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CancelMatchArg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CancelMatchArg& CancelMatchArg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_project_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_project_2eproto();
#endif
  return *default_instance_;
}

CancelMatchArg* CancelMatchArg::default_instance_ = NULL;

CancelMatchArg* CancelMatchArg::New() const {
  return new CancelMatchArg;
}

void CancelMatchArg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    params_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CancelMatchArg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 params = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &params_)));
          set_has_params();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CancelMatchArg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 params = 1;
  if (has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->params(), output);
  }

}

int CancelMatchArg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 params = 1;
    if (has_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->params());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CancelMatchArg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CancelMatchArg*>(&from));
}

void CancelMatchArg::MergeFrom(const CancelMatchArg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_params()) {
      set_params(from.params());
    }
  }
}

void CancelMatchArg::CopyFrom(const CancelMatchArg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelMatchArg::IsInitialized() const {

  return true;
}

void CancelMatchArg::Swap(CancelMatchArg* other) {
  if (other != this) {
    std::swap(params_, other->params_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CancelMatchArg::GetTypeName() const {
  return "CBR.CancelMatchArg";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CBR

// @@protoc_insertion_point(global_scope)
