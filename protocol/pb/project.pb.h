// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: project.proto

#ifndef PROTOBUF_project_2eproto__INCLUDED
#define PROTOBUF_project_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "enum.pb.h"
// @@protoc_insertion_point(includes)

namespace CBR {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_project_2eproto();
void protobuf_AssignDesc_project_2eproto();
void protobuf_ShutdownFile_project_2eproto();

class npcdata;
class RegisterGateToHallRes;
class RegisterGateToHallReq;
class RegisterHallToDbReq;
class RegisterHallToDbRes;
class UpRoleDataReq;
class UpRoleDataRes;
class DownRoleDataReq;
class DownRoleDataRes;
class ChickDinnerSaveData;
class ChickDinnerSaveDataArg;
class ChickDinnerSaveDataRes;
class RegisterGateToLoginArg;
class RegisterGateToLoginRes;
class ChickDinnerQueryDataArg;
class ChickDinnerQueryDataRes;
class RegAccountArg;
class RegAccountRes;
class LoginDataArg;
class LoginDataRes;
class appear;
class AttriBase;
class ActorBase;
class LoginSession2Gate;
class EnterGameArg;
class EnterGameRes;
class ActorDataArg;
class ActorDataRes;
class CreateActorReq;
class CreateActorRes;
class LoginOutData;
class UserSaveData;
class ActorInfo;
class ActorBrief;
class UpdateActorDataArg;
class UpdateActorDataRes;
class ClientAuthArg;
class ClientAuthRes;
class HeartbeatData;
class Friend2Db;
class RegisterHallToDcmArg;
class RegisterHallToDcmRes;
class StartMatchArg;
class StartMatchRes;
class MatchPlayer;
class MatchResult;
class MatchRobot;
class RoomInfo;
class CancelMatchArg;

// ===================================================================

class npcdata : public ::google::protobuf::MessageLite {
 public:
  npcdata();
  virtual ~npcdata();

  npcdata(const npcdata& from);

  inline npcdata& operator=(const npcdata& from) {
    CopyFrom(from);
    return *this;
  }

  static const npcdata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const npcdata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(npcdata* other);

  // implements Message ----------------------------------------------

  npcdata* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const npcdata& from);
  void MergeFrom(const npcdata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional uint32 buff = 2;
  inline bool has_buff() const;
  inline void clear_buff();
  static const int kBuffFieldNumber = 2;
  inline ::google::protobuf::uint32 buff() const;
  inline void set_buff(::google::protobuf::uint32 value);

  // optional int32 appear = 3;
  inline bool has_appear() const;
  inline void clear_appear();
  static const int kAppearFieldNumber = 3;
  inline ::google::protobuf::int32 appear() const;
  inline void set_appear(::google::protobuf::int32 value);

  // optional int64 ff = 4;
  inline bool has_ff() const;
  inline void clear_ff();
  static const int kFfFieldNumber = 4;
  inline ::google::protobuf::int64 ff() const;
  inline void set_ff(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:CBR.npcdata)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_buff();
  inline void clear_has_buff();
  inline void set_has_appear();
  inline void clear_has_appear();
  inline void set_has_ff();
  inline void clear_has_ff();

  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 buff_;
  ::google::protobuf::int64 ff_;
  ::google::protobuf::int32 appear_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static npcdata* default_instance_;
};
// -------------------------------------------------------------------

class RegisterGateToHallRes : public ::google::protobuf::MessageLite {
 public:
  RegisterGateToHallRes();
  virtual ~RegisterGateToHallRes();

  RegisterGateToHallRes(const RegisterGateToHallRes& from);

  inline RegisterGateToHallRes& operator=(const RegisterGateToHallRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterGateToHallRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterGateToHallRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterGateToHallRes* other);

  // implements Message ----------------------------------------------

  RegisterGateToHallRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterGateToHallRes& from);
  void MergeFrom(const RegisterGateToHallRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CBR::ErrorCode result() const;
  inline void set_result(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.RegisterGateToHallRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegisterGateToHallRes* default_instance_;
};
// -------------------------------------------------------------------

class RegisterGateToHallReq : public ::google::protobuf::MessageLite {
 public:
  RegisterGateToHallReq();
  virtual ~RegisterGateToHallReq();

  RegisterGateToHallReq(const RegisterGateToHallReq& from);

  inline RegisterGateToHallReq& operator=(const RegisterGateToHallReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterGateToHallReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterGateToHallReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterGateToHallReq* other);

  // implements Message ----------------------------------------------

  RegisterGateToHallReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterGateToHallReq& from);
  void MergeFrom(const RegisterGateToHallReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 zoneid = 1;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 1;
  inline ::google::protobuf::uint32 zoneid() const;
  inline void set_zoneid(::google::protobuf::uint32 value);

  // optional uint32 serverid = 2;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 2;
  inline ::google::protobuf::uint32 serverid() const;
  inline void set_serverid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.RegisterGateToHallReq)
 private:
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_serverid();
  inline void clear_has_serverid();

  ::google::protobuf::uint32 zoneid_;
  ::google::protobuf::uint32 serverid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegisterGateToHallReq* default_instance_;
};
// -------------------------------------------------------------------

class RegisterHallToDbReq : public ::google::protobuf::MessageLite {
 public:
  RegisterHallToDbReq();
  virtual ~RegisterHallToDbReq();

  RegisterHallToDbReq(const RegisterHallToDbReq& from);

  inline RegisterHallToDbReq& operator=(const RegisterHallToDbReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterHallToDbReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterHallToDbReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterHallToDbReq* other);

  // implements Message ----------------------------------------------

  RegisterHallToDbReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterHallToDbReq& from);
  void MergeFrom(const RegisterHallToDbReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 serverid = 1;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 1;
  inline ::google::protobuf::uint32 serverid() const;
  inline void set_serverid(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:CBR.RegisterHallToDbReq)
 private:
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::uint32 serverid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegisterHallToDbReq* default_instance_;
};
// -------------------------------------------------------------------

class RegisterHallToDbRes : public ::google::protobuf::MessageLite {
 public:
  RegisterHallToDbRes();
  virtual ~RegisterHallToDbRes();

  RegisterHallToDbRes(const RegisterHallToDbRes& from);

  inline RegisterHallToDbRes& operator=(const RegisterHallToDbRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterHallToDbRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterHallToDbRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterHallToDbRes* other);

  // implements Message ----------------------------------------------

  RegisterHallToDbRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterHallToDbRes& from);
  void MergeFrom(const RegisterHallToDbRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::CBR::ErrorCode ret() const;
  inline void set_ret(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.RegisterHallToDbRes)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegisterHallToDbRes* default_instance_;
};
// -------------------------------------------------------------------

class UpRoleDataReq : public ::google::protobuf::MessageLite {
 public:
  UpRoleDataReq();
  virtual ~UpRoleDataReq();

  UpRoleDataReq(const UpRoleDataReq& from);

  inline UpRoleDataReq& operator=(const UpRoleDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpRoleDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpRoleDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpRoleDataReq* other);

  // implements Message ----------------------------------------------

  UpRoleDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpRoleDataReq& from);
  void MergeFrom(const UpRoleDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline ::google::protobuf::uint64 roleid() const;
  inline void set_roleid(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 killer = 4;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 4;
  inline ::google::protobuf::uint32 killer() const;
  inline void set_killer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.UpRoleDataReq)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_killer();
  inline void clear_has_killer();

  ::google::protobuf::uint64 roleid_;
  ::std::string* name_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 killer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static UpRoleDataReq* default_instance_;
};
// -------------------------------------------------------------------

class UpRoleDataRes : public ::google::protobuf::MessageLite {
 public:
  UpRoleDataRes();
  virtual ~UpRoleDataRes();

  UpRoleDataRes(const UpRoleDataRes& from);

  inline UpRoleDataRes& operator=(const UpRoleDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpRoleDataRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpRoleDataRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpRoleDataRes* other);

  // implements Message ----------------------------------------------

  UpRoleDataRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpRoleDataRes& from);
  void MergeFrom(const UpRoleDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.UpRoleDataRes)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static UpRoleDataRes* default_instance_;
};
// -------------------------------------------------------------------

class DownRoleDataReq : public ::google::protobuf::MessageLite {
 public:
  DownRoleDataReq();
  virtual ~DownRoleDataReq();

  DownRoleDataReq(const DownRoleDataReq& from);

  inline DownRoleDataReq& operator=(const DownRoleDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const DownRoleDataReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DownRoleDataReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DownRoleDataReq* other);

  // implements Message ----------------------------------------------

  DownRoleDataReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DownRoleDataReq& from);
  void MergeFrom(const DownRoleDataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline ::google::protobuf::uint64 roleid() const;
  inline void set_roleid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.DownRoleDataReq)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::google::protobuf::uint64 roleid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static DownRoleDataReq* default_instance_;
};
// -------------------------------------------------------------------

class DownRoleDataRes : public ::google::protobuf::MessageLite {
 public:
  DownRoleDataRes();
  virtual ~DownRoleDataRes();

  DownRoleDataRes(const DownRoleDataRes& from);

  inline DownRoleDataRes& operator=(const DownRoleDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const DownRoleDataRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DownRoleDataRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DownRoleDataRes* other);

  // implements Message ----------------------------------------------

  DownRoleDataRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DownRoleDataRes& from);
  void MergeFrom(const DownRoleDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline ::google::protobuf::uint64 roleid() const;
  inline void set_roleid(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 killer = 4;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 4;
  inline ::google::protobuf::uint32 killer() const;
  inline void set_killer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.DownRoleDataRes)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_killer();
  inline void clear_has_killer();

  ::google::protobuf::uint64 roleid_;
  ::std::string* name_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 killer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static DownRoleDataRes* default_instance_;
};
// -------------------------------------------------------------------

class ChickDinnerSaveData : public ::google::protobuf::MessageLite {
 public:
  ChickDinnerSaveData();
  virtual ~ChickDinnerSaveData();

  ChickDinnerSaveData(const ChickDinnerSaveData& from);

  inline ChickDinnerSaveData& operator=(const ChickDinnerSaveData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChickDinnerSaveData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChickDinnerSaveData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChickDinnerSaveData* other);

  // implements Message ----------------------------------------------

  ChickDinnerSaveData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChickDinnerSaveData& from);
  void MergeFrom(const ChickDinnerSaveData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline ::google::protobuf::uint64 roleid() const;
  inline void set_roleid(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 killer = 3;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 3;
  inline ::google::protobuf::uint32 killer() const;
  inline void set_killer(::google::protobuf::uint32 value);

  // optional uint64 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::uint64 score() const;
  inline void set_score(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.ChickDinnerSaveData)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_killer();
  inline void clear_has_killer();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::uint64 roleid_;
  ::std::string* name_;
  ::google::protobuf::uint64 score_;
  ::google::protobuf::uint32 killer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ChickDinnerSaveData* default_instance_;
};
// -------------------------------------------------------------------

class ChickDinnerSaveDataArg : public ::google::protobuf::MessageLite {
 public:
  ChickDinnerSaveDataArg();
  virtual ~ChickDinnerSaveDataArg();

  ChickDinnerSaveDataArg(const ChickDinnerSaveDataArg& from);

  inline ChickDinnerSaveDataArg& operator=(const ChickDinnerSaveDataArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChickDinnerSaveDataArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChickDinnerSaveDataArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChickDinnerSaveDataArg* other);

  // implements Message ----------------------------------------------

  ChickDinnerSaveDataArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChickDinnerSaveDataArg& from);
  void MergeFrom(const ChickDinnerSaveDataArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.DBOperType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::CBR::DBOperType type() const;
  inline void set_type(::CBR::DBOperType value);

  // optional .CBR.ChickDinnerSaveData data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::CBR::ChickDinnerSaveData& data() const;
  inline ::CBR::ChickDinnerSaveData* mutable_data();
  inline ::CBR::ChickDinnerSaveData* release_data();
  inline void set_allocated_data(::CBR::ChickDinnerSaveData* data);

  // @@protoc_insertion_point(class_scope:CBR.ChickDinnerSaveDataArg)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::CBR::ChickDinnerSaveData* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ChickDinnerSaveDataArg* default_instance_;
};
// -------------------------------------------------------------------

class ChickDinnerSaveDataRes : public ::google::protobuf::MessageLite {
 public:
  ChickDinnerSaveDataRes();
  virtual ~ChickDinnerSaveDataRes();

  ChickDinnerSaveDataRes(const ChickDinnerSaveDataRes& from);

  inline ChickDinnerSaveDataRes& operator=(const ChickDinnerSaveDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChickDinnerSaveDataRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChickDinnerSaveDataRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChickDinnerSaveDataRes* other);

  // implements Message ----------------------------------------------

  ChickDinnerSaveDataRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChickDinnerSaveDataRes& from);
  void MergeFrom(const ChickDinnerSaveDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CBR::ErrorCode result() const;
  inline void set_result(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.ChickDinnerSaveDataRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ChickDinnerSaveDataRes* default_instance_;
};
// -------------------------------------------------------------------

class RegisterGateToLoginArg : public ::google::protobuf::MessageLite {
 public:
  RegisterGateToLoginArg();
  virtual ~RegisterGateToLoginArg();

  RegisterGateToLoginArg(const RegisterGateToLoginArg& from);

  inline RegisterGateToLoginArg& operator=(const RegisterGateToLoginArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterGateToLoginArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterGateToLoginArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterGateToLoginArg* other);

  // implements Message ----------------------------------------------

  RegisterGateToLoginArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterGateToLoginArg& from);
  void MergeFrom(const RegisterGateToLoginArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 serverid = 1;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 1;
  inline ::google::protobuf::uint32 serverid() const;
  inline void set_serverid(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.RegisterGateToLoginArg)
 private:
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::std::string* name_;
  ::google::protobuf::uint32 serverid_;
  ::google::protobuf::uint32 port_;
  ::std::string* ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegisterGateToLoginArg* default_instance_;
};
// -------------------------------------------------------------------

class RegisterGateToLoginRes : public ::google::protobuf::MessageLite {
 public:
  RegisterGateToLoginRes();
  virtual ~RegisterGateToLoginRes();

  RegisterGateToLoginRes(const RegisterGateToLoginRes& from);

  inline RegisterGateToLoginRes& operator=(const RegisterGateToLoginRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterGateToLoginRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterGateToLoginRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterGateToLoginRes* other);

  // implements Message ----------------------------------------------

  RegisterGateToLoginRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterGateToLoginRes& from);
  void MergeFrom(const RegisterGateToLoginRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CBR::ErrorCode result() const;
  inline void set_result(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.RegisterGateToLoginRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegisterGateToLoginRes* default_instance_;
};
// -------------------------------------------------------------------

class ChickDinnerQueryDataArg : public ::google::protobuf::MessageLite {
 public:
  ChickDinnerQueryDataArg();
  virtual ~ChickDinnerQueryDataArg();

  ChickDinnerQueryDataArg(const ChickDinnerQueryDataArg& from);

  inline ChickDinnerQueryDataArg& operator=(const ChickDinnerQueryDataArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChickDinnerQueryDataArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChickDinnerQueryDataArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChickDinnerQueryDataArg* other);

  // implements Message ----------------------------------------------

  ChickDinnerQueryDataArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChickDinnerQueryDataArg& from);
  void MergeFrom(const ChickDinnerQueryDataArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline ::google::protobuf::uint64 roleid() const;
  inline void set_roleid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.ChickDinnerQueryDataArg)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::google::protobuf::uint64 roleid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ChickDinnerQueryDataArg* default_instance_;
};
// -------------------------------------------------------------------

class ChickDinnerQueryDataRes : public ::google::protobuf::MessageLite {
 public:
  ChickDinnerQueryDataRes();
  virtual ~ChickDinnerQueryDataRes();

  ChickDinnerQueryDataRes(const ChickDinnerQueryDataRes& from);

  inline ChickDinnerQueryDataRes& operator=(const ChickDinnerQueryDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChickDinnerQueryDataRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChickDinnerQueryDataRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChickDinnerQueryDataRes* other);

  // implements Message ----------------------------------------------

  ChickDinnerQueryDataRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChickDinnerQueryDataRes& from);
  void MergeFrom(const ChickDinnerQueryDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ChickDinnerSaveData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::CBR::ChickDinnerSaveData& data() const;
  inline ::CBR::ChickDinnerSaveData* mutable_data();
  inline ::CBR::ChickDinnerSaveData* release_data();
  inline void set_allocated_data(::CBR::ChickDinnerSaveData* data);

  // optional .CBR.ErrorCode error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.ChickDinnerQueryDataRes)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_error();
  inline void clear_has_error();

  ::CBR::ChickDinnerSaveData* data_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ChickDinnerQueryDataRes* default_instance_;
};
// -------------------------------------------------------------------

class RegAccountArg : public ::google::protobuf::MessageLite {
 public:
  RegAccountArg();
  virtual ~RegAccountArg();

  RegAccountArg(const RegAccountArg& from);

  inline RegAccountArg& operator=(const RegAccountArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegAccountArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegAccountArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegAccountArg* other);

  // implements Message ----------------------------------------------

  RegAccountArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegAccountArg& from);
  void MergeFrom(const RegAccountArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .CBR.Channel channnel = 3;
  inline bool has_channnel() const;
  inline void clear_channnel();
  static const int kChannnelFieldNumber = 3;
  inline ::CBR::Channel channnel() const;
  inline void set_channnel(::CBR::Channel value);

  // optional string DeviceId = 4;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 4;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string ip = 5;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 5;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:CBR.RegAccountArg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_channnel();
  inline void clear_has_channnel();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::std::string* name_;
  ::std::string* password_;
  ::std::string* deviceid_;
  ::std::string* ip_;
  int channnel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegAccountArg* default_instance_;
};
// -------------------------------------------------------------------

class RegAccountRes : public ::google::protobuf::MessageLite {
 public:
  RegAccountRes();
  virtual ~RegAccountRes();

  RegAccountRes(const RegAccountRes& from);

  inline RegAccountRes& operator=(const RegAccountRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegAccountRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegAccountRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegAccountRes* other);

  // implements Message ----------------------------------------------

  RegAccountRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegAccountRes& from);
  void MergeFrom(const RegAccountRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // optional uint64 accountid = 2;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 2;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.RegAccountRes)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_accountid();
  inline void clear_has_accountid();

  ::google::protobuf::uint64 accountid_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegAccountRes* default_instance_;
};
// -------------------------------------------------------------------

class LoginDataArg : public ::google::protobuf::MessageLite {
 public:
  LoginDataArg();
  virtual ~LoginDataArg();

  LoginDataArg(const LoginDataArg& from);

  inline LoginDataArg& operator=(const LoginDataArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginDataArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginDataArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginDataArg* other);

  // implements Message ----------------------------------------------

  LoginDataArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginDataArg& from);
  void MergeFrom(const LoginDataArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes passward = 2;
  inline bool has_passward() const;
  inline void clear_passward();
  static const int kPasswardFieldNumber = 2;
  inline const ::std::string& passward() const;
  inline void set_passward(const ::std::string& value);
  inline void set_passward(const char* value);
  inline void set_passward(const void* value, size_t size);
  inline ::std::string* mutable_passward();
  inline ::std::string* release_passward();
  inline void set_allocated_passward(::std::string* passward);

  // optional string deviceid = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 3;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:CBR.LoginDataArg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_passward();
  inline void clear_has_passward();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::std::string* name_;
  ::std::string* passward_;
  ::std::string* deviceid_;
  ::std::string* ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static LoginDataArg* default_instance_;
};
// -------------------------------------------------------------------

class LoginDataRes : public ::google::protobuf::MessageLite {
 public:
  LoginDataRes();
  virtual ~LoginDataRes();

  LoginDataRes(const LoginDataRes& from);

  inline LoginDataRes& operator=(const LoginDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginDataRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginDataRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginDataRes* other);

  // implements Message ----------------------------------------------

  LoginDataRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginDataRes& from);
  void MergeFrom(const LoginDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CBR::ErrorCode result() const;
  inline void set_result(::CBR::ErrorCode value);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint64 session = 4;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 4;
  inline ::google::protobuf::uint64 session() const;
  inline void set_session(::google::protobuf::uint64 value);

  // optional uint64 accoutid = 5;
  inline bool has_accoutid() const;
  inline void clear_accoutid();
  static const int kAccoutidFieldNumber = 5;
  inline ::google::protobuf::uint64 accoutid() const;
  inline void set_accoutid(::google::protobuf::uint64 value);

  // optional string accountname = 6;
  inline bool has_accountname() const;
  inline void clear_accountname();
  static const int kAccountnameFieldNumber = 6;
  inline const ::std::string& accountname() const;
  inline void set_accountname(const ::std::string& value);
  inline void set_accountname(const char* value);
  inline void set_accountname(const char* value, size_t size);
  inline ::std::string* mutable_accountname();
  inline ::std::string* release_accountname();
  inline void set_allocated_accountname(::std::string* accountname);

  // optional uint32 state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // repeated .CBR.ActorBrief actorlist = 8;
  inline int actorlist_size() const;
  inline void clear_actorlist();
  static const int kActorlistFieldNumber = 8;
  inline const ::CBR::ActorBrief& actorlist(int index) const;
  inline ::CBR::ActorBrief* mutable_actorlist(int index);
  inline ::CBR::ActorBrief* add_actorlist();
  inline const ::google::protobuf::RepeatedPtrField< ::CBR::ActorBrief >&
      actorlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::CBR::ActorBrief >*
      mutable_actorlist();

  // @@protoc_insertion_point(class_scope:CBR.LoginDataRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_accoutid();
  inline void clear_has_accoutid();
  inline void set_has_accountname();
  inline void clear_has_accountname();
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string* ip_;
  int result_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint64 session_;
  ::google::protobuf::uint64 accoutid_;
  ::std::string* accountname_;
  ::google::protobuf::RepeatedPtrField< ::CBR::ActorBrief > actorlist_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static LoginDataRes* default_instance_;
};
// -------------------------------------------------------------------

class appear : public ::google::protobuf::MessageLite {
 public:
  appear();
  virtual ~appear();

  appear(const appear& from);

  inline appear& operator=(const appear& from) {
    CopyFrom(from);
    return *this;
  }

  static const appear& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const appear* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(appear* other);

  // implements Message ----------------------------------------------

  appear* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const appear& from);
  void MergeFrom(const appear& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 actid = 1;
  inline bool has_actid() const;
  inline void clear_actid();
  static const int kActidFieldNumber = 1;
  inline ::google::protobuf::uint64 actid() const;
  inline void set_actid(::google::protobuf::uint64 value);

  // optional string actorname = 2;
  inline bool has_actorname() const;
  inline void clear_actorname();
  static const int kActornameFieldNumber = 2;
  inline const ::std::string& actorname() const;
  inline void set_actorname(const ::std::string& value);
  inline void set_actorname(const char* value);
  inline void set_actorname(const char* value, size_t size);
  inline ::std::string* mutable_actorname();
  inline ::std::string* release_actorname();
  inline void set_allocated_actorname(::std::string* actorname);

  // optional uint32 actortype = 3;
  inline bool has_actortype() const;
  inline void clear_actortype();
  static const int kActortypeFieldNumber = 3;
  inline ::google::protobuf::uint32 actortype() const;
  inline void set_actortype(::google::protobuf::uint32 value);

  // optional uint32 resid = 4;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResidFieldNumber = 4;
  inline ::google::protobuf::uint32 resid() const;
  inline void set_resid(::google::protobuf::uint32 value);

  // optional uint32 hairstyle = 5;
  inline bool has_hairstyle() const;
  inline void clear_hairstyle();
  static const int kHairstyleFieldNumber = 5;
  inline ::google::protobuf::uint32 hairstyle() const;
  inline void set_hairstyle(::google::protobuf::uint32 value);

  // optional uint32 createtime = 6;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 6;
  inline ::google::protobuf::uint32 createtime() const;
  inline void set_createtime(::google::protobuf::uint32 value);

  // optional uint32 sex = 7;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 7;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional uint32 seqindex = 8;
  inline bool has_seqindex() const;
  inline void clear_seqindex();
  static const int kSeqindexFieldNumber = 8;
  inline ::google::protobuf::uint32 seqindex() const;
  inline void set_seqindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.appear)
 private:
  inline void set_has_actid();
  inline void clear_has_actid();
  inline void set_has_actorname();
  inline void clear_has_actorname();
  inline void set_has_actortype();
  inline void clear_has_actortype();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_hairstyle();
  inline void clear_has_hairstyle();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_seqindex();
  inline void clear_has_seqindex();

  ::google::protobuf::uint64 actid_;
  ::std::string* actorname_;
  ::google::protobuf::uint32 actortype_;
  ::google::protobuf::uint32 resid_;
  ::google::protobuf::uint32 hairstyle_;
  ::google::protobuf::uint32 createtime_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 seqindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static appear* default_instance_;
};
// -------------------------------------------------------------------

class AttriBase : public ::google::protobuf::MessageLite {
 public:
  AttriBase();
  virtual ~AttriBase();

  AttriBase(const AttriBase& from);

  inline AttriBase& operator=(const AttriBase& from) {
    CopyFrom(from);
    return *this;
  }

  static const AttriBase& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttriBase* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttriBase* other);

  // implements Message ----------------------------------------------

  AttriBase* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttriBase& from);
  void MergeFrom(const AttriBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ActorLevel = 1;
  inline bool has_actorlevel() const;
  inline void clear_actorlevel();
  static const int kActorLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 actorlevel() const;
  inline void set_actorlevel(::google::protobuf::uint32 value);

  // optional uint64 ActorExp = 2;
  inline bool has_actorexp() const;
  inline void clear_actorexp();
  static const int kActorExpFieldNumber = 2;
  inline ::google::protobuf::uint64 actorexp() const;
  inline void set_actorexp(::google::protobuf::uint64 value);

  // optional uint32 Vigor = 3;
  inline bool has_vigor() const;
  inline void clear_vigor();
  static const int kVigorFieldNumber = 3;
  inline ::google::protobuf::uint32 vigor() const;
  inline void set_vigor(::google::protobuf::uint32 value);

  // optional uint32 VipLev = 4;
  inline bool has_viplev() const;
  inline void clear_viplev();
  static const int kVipLevFieldNumber = 4;
  inline ::google::protobuf::uint32 viplev() const;
  inline void set_viplev(::google::protobuf::uint32 value);

  // optional uint32 Fighting = 5;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 5;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 Fire = 6;
  inline bool has_fire() const;
  inline void clear_fire();
  static const int kFireFieldNumber = 6;
  inline ::google::protobuf::uint32 fire() const;
  inline void set_fire(::google::protobuf::uint32 value);

  // optional uint32 score = 7;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 7;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.AttriBase)
 private:
  inline void set_has_actorlevel();
  inline void clear_has_actorlevel();
  inline void set_has_actorexp();
  inline void clear_has_actorexp();
  inline void set_has_vigor();
  inline void clear_has_vigor();
  inline void set_has_viplev();
  inline void clear_has_viplev();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_fire();
  inline void clear_has_fire();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::uint64 actorexp_;
  ::google::protobuf::uint32 actorlevel_;
  ::google::protobuf::uint32 vigor_;
  ::google::protobuf::uint32 viplev_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 fire_;
  ::google::protobuf::uint32 score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static AttriBase* default_instance_;
};
// -------------------------------------------------------------------

class ActorBase : public ::google::protobuf::MessageLite {
 public:
  ActorBase();
  virtual ~ActorBase();

  ActorBase(const ActorBase& from);

  inline ActorBase& operator=(const ActorBase& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActorBase& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActorBase* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActorBase* other);

  // implements Message ----------------------------------------------

  ActorBase* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActorBase& from);
  void MergeFrom(const ActorBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 accountid = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // optional .CBR.appear app = 2;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 2;
  inline const ::CBR::appear& app() const;
  inline ::CBR::appear* mutable_app();
  inline ::CBR::appear* release_app();
  inline void set_allocated_app(::CBR::appear* app);

  // optional .CBR.AttriBase att = 3;
  inline bool has_att() const;
  inline void clear_att();
  static const int kAttFieldNumber = 3;
  inline const ::CBR::AttriBase& att() const;
  inline ::CBR::AttriBase* mutable_att();
  inline ::CBR::AttriBase* release_att();
  inline void set_allocated_att(::CBR::AttriBase* att);

  // optional uint32 verion = 4;
  inline bool has_verion() const;
  inline void clear_verion();
  static const int kVerionFieldNumber = 4;
  inline ::google::protobuf::uint32 verion() const;
  inline void set_verion(::google::protobuf::uint32 value);

  // optional uint32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.ActorBase)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_att();
  inline void clear_has_att();
  inline void set_has_verion();
  inline void clear_has_verion();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::uint64 accountid_;
  ::CBR::appear* app_;
  ::CBR::AttriBase* att_;
  ::google::protobuf::uint32 verion_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ActorBase* default_instance_;
};
// -------------------------------------------------------------------

class LoginSession2Gate : public ::google::protobuf::MessageLite {
 public:
  LoginSession2Gate();
  virtual ~LoginSession2Gate();

  LoginSession2Gate(const LoginSession2Gate& from);

  inline LoginSession2Gate& operator=(const LoginSession2Gate& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginSession2Gate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginSession2Gate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginSession2Gate* other);

  // implements Message ----------------------------------------------

  LoginSession2Gate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginSession2Gate& from);
  void MergeFrom(const LoginSession2Gate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint64 session() const;
  inline void set_session(::google::protobuf::uint64 value);

  // optional uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint64 accountid = 3;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 3;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // optional string accountname = 4;
  inline bool has_accountname() const;
  inline void clear_accountname();
  static const int kAccountnameFieldNumber = 4;
  inline const ::std::string& accountname() const;
  inline void set_accountname(const ::std::string& value);
  inline void set_accountname(const char* value);
  inline void set_accountname(const char* value, size_t size);
  inline ::std::string* mutable_accountname();
  inline ::std::string* release_accountname();
  inline void set_allocated_accountname(::std::string* accountname);

  // @@protoc_insertion_point(class_scope:CBR.LoginSession2Gate)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_accountname();
  inline void clear_has_accountname();

  ::google::protobuf::uint64 session_;
  ::google::protobuf::uint64 accountid_;
  ::std::string* accountname_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static LoginSession2Gate* default_instance_;
};
// -------------------------------------------------------------------

class EnterGameArg : public ::google::protobuf::MessageLite {
 public:
  EnterGameArg();
  virtual ~EnterGameArg();

  EnterGameArg(const EnterGameArg& from);

  inline EnterGameArg& operator=(const EnterGameArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterGameArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterGameArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterGameArg* other);

  // implements Message ----------------------------------------------

  EnterGameArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterGameArg& from);
  void MergeFrom(const EnterGameArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 accountid = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // optional uint64 token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // optional uint64 actorid = 3;
  inline bool has_actorid() const;
  inline void clear_actorid();
  static const int kActoridFieldNumber = 3;
  inline ::google::protobuf::uint64 actorid() const;
  inline void set_actorid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.EnterGameArg)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_actorid();
  inline void clear_has_actorid();

  ::google::protobuf::uint64 accountid_;
  ::google::protobuf::uint64 token_;
  ::google::protobuf::uint64 actorid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static EnterGameArg* default_instance_;
};
// -------------------------------------------------------------------

class EnterGameRes : public ::google::protobuf::MessageLite {
 public:
  EnterGameRes();
  virtual ~EnterGameRes();

  EnterGameRes(const EnterGameRes& from);

  inline EnterGameRes& operator=(const EnterGameRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterGameRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterGameRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterGameRes* other);

  // implements Message ----------------------------------------------

  EnterGameRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterGameRes& from);
  void MergeFrom(const EnterGameRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // repeated .CBR.ActorBase actorlist = 2;
  inline int actorlist_size() const;
  inline void clear_actorlist();
  static const int kActorlistFieldNumber = 2;
  inline const ::CBR::ActorBase& actorlist(int index) const;
  inline ::CBR::ActorBase* mutable_actorlist(int index);
  inline ::CBR::ActorBase* add_actorlist();
  inline const ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase >&
      actorlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase >*
      mutable_actorlist();

  // @@protoc_insertion_point(class_scope:CBR.EnterGameRes)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase > actorlist_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static EnterGameRes* default_instance_;
};
// -------------------------------------------------------------------

class ActorDataArg : public ::google::protobuf::MessageLite {
 public:
  ActorDataArg();
  virtual ~ActorDataArg();

  ActorDataArg(const ActorDataArg& from);

  inline ActorDataArg& operator=(const ActorDataArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActorDataArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActorDataArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActorDataArg* other);

  // implements Message ----------------------------------------------

  ActorDataArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActorDataArg& from);
  void MergeFrom(const ActorDataArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rpcid = 1;
  inline bool has_rpcid() const;
  inline void clear_rpcid();
  static const int kRpcidFieldNumber = 1;
  inline ::google::protobuf::int32 rpcid() const;
  inline void set_rpcid(::google::protobuf::int32 value);

  // optional uint64 actorid = 2;
  inline bool has_actorid() const;
  inline void clear_actorid();
  static const int kActoridFieldNumber = 2;
  inline ::google::protobuf::uint64 actorid() const;
  inline void set_actorid(::google::protobuf::uint64 value);

  // optional uint64 sessionid = 3;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionidFieldNumber = 3;
  inline ::google::protobuf::uint64 sessionid() const;
  inline void set_sessionid(::google::protobuf::uint64 value);

  // optional uint64 accountid = 4;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 4;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.ActorDataArg)
 private:
  inline void set_has_rpcid();
  inline void clear_has_rpcid();
  inline void set_has_actorid();
  inline void clear_has_actorid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_accountid();
  inline void clear_has_accountid();

  ::google::protobuf::uint64 actorid_;
  ::google::protobuf::uint64 sessionid_;
  ::google::protobuf::uint64 accountid_;
  ::google::protobuf::int32 rpcid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ActorDataArg* default_instance_;
};
// -------------------------------------------------------------------

class ActorDataRes : public ::google::protobuf::MessageLite {
 public:
  ActorDataRes();
  virtual ~ActorDataRes();

  ActorDataRes(const ActorDataRes& from);

  inline ActorDataRes& operator=(const ActorDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActorDataRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActorDataRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActorDataRes* other);

  // implements Message ----------------------------------------------

  ActorDataRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActorDataRes& from);
  void MergeFrom(const ActorDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CBR.ActorBase actorlist = 1;
  inline int actorlist_size() const;
  inline void clear_actorlist();
  static const int kActorlistFieldNumber = 1;
  inline const ::CBR::ActorBase& actorlist(int index) const;
  inline ::CBR::ActorBase* mutable_actorlist(int index);
  inline ::CBR::ActorBase* add_actorlist();
  inline const ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase >&
      actorlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase >*
      mutable_actorlist();

  // optional .CBR.ErrorCode error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // optional uint32 rpcid = 3;
  inline bool has_rpcid() const;
  inline void clear_rpcid();
  static const int kRpcidFieldNumber = 3;
  inline ::google::protobuf::uint32 rpcid() const;
  inline void set_rpcid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.ActorDataRes)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_rpcid();
  inline void clear_has_rpcid();

  ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase > actorlist_;
  int error_;
  ::google::protobuf::uint32 rpcid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ActorDataRes* default_instance_;
};
// -------------------------------------------------------------------

class CreateActorReq : public ::google::protobuf::MessageLite {
 public:
  CreateActorReq();
  virtual ~CreateActorReq();

  CreateActorReq(const CreateActorReq& from);

  inline CreateActorReq& operator=(const CreateActorReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateActorReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateActorReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateActorReq* other);

  // implements Message ----------------------------------------------

  CreateActorReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateActorReq& from);
  void MergeFrom(const CreateActorReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 hairid = 1;
  inline bool has_hairid() const;
  inline void clear_hairid();
  static const int kHairidFieldNumber = 1;
  inline ::google::protobuf::uint32 hairid() const;
  inline void set_hairid(::google::protobuf::uint32 value);

  // optional uint32 faceid = 2;
  inline bool has_faceid() const;
  inline void clear_faceid();
  static const int kFaceidFieldNumber = 2;
  inline ::google::protobuf::uint32 faceid() const;
  inline void set_faceid(::google::protobuf::uint32 value);

  // optional uint32 sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 accountid = 5;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 5;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // optional uint32 seqindex = 6;
  inline bool has_seqindex() const;
  inline void clear_seqindex();
  static const int kSeqindexFieldNumber = 6;
  inline ::google::protobuf::uint32 seqindex() const;
  inline void set_seqindex(::google::protobuf::uint32 value);

  // optional uint32 actortype = 7;
  inline bool has_actortype() const;
  inline void clear_actortype();
  static const int kActortypeFieldNumber = 7;
  inline ::google::protobuf::uint32 actortype() const;
  inline void set_actortype(::google::protobuf::uint32 value);

  // optional uint32 resid = 8;
  inline bool has_resid() const;
  inline void clear_resid();
  static const int kResidFieldNumber = 8;
  inline ::google::protobuf::uint32 resid() const;
  inline void set_resid(::google::protobuf::uint32 value);

  // optional uint32 rpcid = 9;
  inline bool has_rpcid() const;
  inline void clear_rpcid();
  static const int kRpcidFieldNumber = 9;
  inline ::google::protobuf::uint32 rpcid() const;
  inline void set_rpcid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.CreateActorReq)
 private:
  inline void set_has_hairid();
  inline void clear_has_hairid();
  inline void set_has_faceid();
  inline void clear_has_faceid();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_seqindex();
  inline void clear_has_seqindex();
  inline void set_has_actortype();
  inline void clear_has_actortype();
  inline void set_has_resid();
  inline void clear_has_resid();
  inline void set_has_rpcid();
  inline void clear_has_rpcid();

  ::google::protobuf::uint32 hairid_;
  ::google::protobuf::uint32 faceid_;
  ::std::string* name_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 seqindex_;
  ::google::protobuf::uint64 accountid_;
  ::google::protobuf::uint32 actortype_;
  ::google::protobuf::uint32 resid_;
  ::google::protobuf::uint32 rpcid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static CreateActorReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateActorRes : public ::google::protobuf::MessageLite {
 public:
  CreateActorRes();
  virtual ~CreateActorRes();

  CreateActorRes(const CreateActorRes& from);

  inline CreateActorRes& operator=(const CreateActorRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateActorRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateActorRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateActorRes* other);

  // implements Message ----------------------------------------------

  CreateActorRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateActorRes& from);
  void MergeFrom(const CreateActorRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::CBR::ErrorCode result() const;
  inline void set_result(::CBR::ErrorCode value);

  // optional uint64 accoutid = 2;
  inline bool has_accoutid() const;
  inline void clear_accoutid();
  static const int kAccoutidFieldNumber = 2;
  inline ::google::protobuf::uint64 accoutid() const;
  inline void set_accoutid(::google::protobuf::uint64 value);

  // optional uint64 actorid = 3;
  inline bool has_actorid() const;
  inline void clear_actorid();
  static const int kActoridFieldNumber = 3;
  inline ::google::protobuf::uint64 actorid() const;
  inline void set_actorid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.CreateActorRes)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_accoutid();
  inline void clear_has_accoutid();
  inline void set_has_actorid();
  inline void clear_has_actorid();

  ::google::protobuf::uint64 accoutid_;
  ::google::protobuf::uint64 actorid_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static CreateActorRes* default_instance_;
};
// -------------------------------------------------------------------

class LoginOutData : public ::google::protobuf::MessageLite {
 public:
  LoginOutData();
  virtual ~LoginOutData();

  LoginOutData(const LoginOutData& from);

  inline LoginOutData& operator=(const LoginOutData& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginOutData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginOutData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginOutData* other);

  // implements Message ----------------------------------------------

  LoginOutData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginOutData& from);
  void MergeFrom(const LoginOutData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 session = 1;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 1;
  inline ::google::protobuf::uint64 session() const;
  inline void set_session(::google::protobuf::uint64 value);

  // optional .CBR.ErrorCode error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.LoginOutData)
 private:
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::uint64 session_;
  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static LoginOutData* default_instance_;
};
// -------------------------------------------------------------------

class UserSaveData : public ::google::protobuf::MessageLite {
 public:
  UserSaveData();
  virtual ~UserSaveData();

  UserSaveData(const UserSaveData& from);

  inline UserSaveData& operator=(const UserSaveData& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserSaveData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserSaveData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserSaveData* other);

  // implements Message ----------------------------------------------

  UserSaveData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserSaveData& from);
  void MergeFrom(const UserSaveData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 accountid = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // optional string accountname = 2;
  inline bool has_accountname() const;
  inline void clear_accountname();
  static const int kAccountnameFieldNumber = 2;
  inline const ::std::string& accountname() const;
  inline void set_accountname(const ::std::string& value);
  inline void set_accountname(const char* value);
  inline void set_accountname(const char* value, size_t size);
  inline ::std::string* mutable_accountname();
  inline ::std::string* release_accountname();
  inline void set_allocated_accountname(::std::string* accountname);

  // optional uint32 channel = 3;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 3;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional string passward = 4;
  inline bool has_passward() const;
  inline void clear_passward();
  static const int kPasswardFieldNumber = 4;
  inline const ::std::string& passward() const;
  inline void set_passward(const ::std::string& value);
  inline void set_passward(const char* value);
  inline void set_passward(const char* value, size_t size);
  inline ::std::string* mutable_passward();
  inline ::std::string* release_passward();
  inline void set_allocated_passward(::std::string* passward);

  // optional uint32 isbind = 5;
  inline bool has_isbind() const;
  inline void clear_isbind();
  static const int kIsbindFieldNumber = 5;
  inline ::google::protobuf::uint32 isbind() const;
  inline void set_isbind(::google::protobuf::uint32 value);

  // optional uint64 bindaccountid = 6;
  inline bool has_bindaccountid() const;
  inline void clear_bindaccountid();
  static const int kBindaccountidFieldNumber = 6;
  inline ::google::protobuf::uint64 bindaccountid() const;
  inline void set_bindaccountid(::google::protobuf::uint64 value);

  // optional uint32 bindtime = 7;
  inline bool has_bindtime() const;
  inline void clear_bindtime();
  static const int kBindtimeFieldNumber = 7;
  inline ::google::protobuf::uint32 bindtime() const;
  inline void set_bindtime(::google::protobuf::uint32 value);

  // optional string deviceid = 8;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 8;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string ip = 9;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 9;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 regtime = 10;
  inline bool has_regtime() const;
  inline void clear_regtime();
  static const int kRegtimeFieldNumber = 10;
  inline ::google::protobuf::uint32 regtime() const;
  inline void set_regtime(::google::protobuf::uint32 value);

  // optional uint32 state = 11;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 11;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.UserSaveData)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_accountname();
  inline void clear_has_accountname();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_passward();
  inline void clear_has_passward();
  inline void set_has_isbind();
  inline void clear_has_isbind();
  inline void set_has_bindaccountid();
  inline void clear_has_bindaccountid();
  inline void set_has_bindtime();
  inline void clear_has_bindtime();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_regtime();
  inline void clear_has_regtime();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::uint64 accountid_;
  ::std::string* accountname_;
  ::std::string* passward_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 isbind_;
  ::google::protobuf::uint64 bindaccountid_;
  ::std::string* deviceid_;
  ::google::protobuf::uint32 bindtime_;
  ::google::protobuf::uint32 regtime_;
  ::std::string* ip_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static UserSaveData* default_instance_;
};
// -------------------------------------------------------------------

class ActorInfo : public ::google::protobuf::MessageLite {
 public:
  ActorInfo();
  virtual ~ActorInfo();

  ActorInfo(const ActorInfo& from);

  inline ActorInfo& operator=(const ActorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActorInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActorInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActorInfo* other);

  // implements Message ----------------------------------------------

  ActorInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActorInfo& from);
  void MergeFrom(const ActorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ActorBase actor = 1;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 1;
  inline const ::CBR::ActorBase& actor() const;
  inline ::CBR::ActorBase* mutable_actor();
  inline ::CBR::ActorBase* release_actor();
  inline void set_allocated_actor(::CBR::ActorBase* actor);

  // @@protoc_insertion_point(class_scope:CBR.ActorInfo)
 private:
  inline void set_has_actor();
  inline void clear_has_actor();

  ::CBR::ActorBase* actor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ActorInfo* default_instance_;
};
// -------------------------------------------------------------------

class ActorBrief : public ::google::protobuf::MessageLite {
 public:
  ActorBrief();
  virtual ~ActorBrief();

  ActorBrief(const ActorBrief& from);

  inline ActorBrief& operator=(const ActorBrief& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActorBrief& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActorBrief* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActorBrief* other);

  // implements Message ----------------------------------------------

  ActorBrief* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActorBrief& from);
  void MergeFrom(const ActorBrief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:CBR.ActorBrief)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::uint64 id_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ActorBrief* default_instance_;
};
// -------------------------------------------------------------------

class UpdateActorDataArg : public ::google::protobuf::MessageLite {
 public:
  UpdateActorDataArg();
  virtual ~UpdateActorDataArg();

  UpdateActorDataArg(const UpdateActorDataArg& from);

  inline UpdateActorDataArg& operator=(const UpdateActorDataArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateActorDataArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateActorDataArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateActorDataArg* other);

  // implements Message ----------------------------------------------

  UpdateActorDataArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateActorDataArg& from);
  void MergeFrom(const UpdateActorDataArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ActorBase act = 1;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 1;
  inline const ::CBR::ActorBase& act() const;
  inline ::CBR::ActorBase* mutable_act();
  inline ::CBR::ActorBase* release_act();
  inline void set_allocated_act(::CBR::ActorBase* act);

  // @@protoc_insertion_point(class_scope:CBR.UpdateActorDataArg)
 private:
  inline void set_has_act();
  inline void clear_has_act();

  ::CBR::ActorBase* act_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static UpdateActorDataArg* default_instance_;
};
// -------------------------------------------------------------------

class UpdateActorDataRes : public ::google::protobuf::MessageLite {
 public:
  UpdateActorDataRes();
  virtual ~UpdateActorDataRes();

  UpdateActorDataRes(const UpdateActorDataRes& from);

  inline UpdateActorDataRes& operator=(const UpdateActorDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateActorDataRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateActorDataRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateActorDataRes* other);

  // implements Message ----------------------------------------------

  UpdateActorDataRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateActorDataRes& from);
  void MergeFrom(const UpdateActorDataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.UpdateActorDataRes)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static UpdateActorDataRes* default_instance_;
};
// -------------------------------------------------------------------

class ClientAuthArg : public ::google::protobuf::MessageLite {
 public:
  ClientAuthArg();
  virtual ~ClientAuthArg();

  ClientAuthArg(const ClientAuthArg& from);

  inline ClientAuthArg& operator=(const ClientAuthArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientAuthArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientAuthArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientAuthArg* other);

  // implements Message ----------------------------------------------

  ClientAuthArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientAuthArg& from);
  void MergeFrom(const ClientAuthArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline ::google::protobuf::uint64 token() const;
  inline void set_token(::google::protobuf::uint64 value);

  // optional uint64 userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.ClientAuthArg)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::uint64 token_;
  ::google::protobuf::uint64 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ClientAuthArg* default_instance_;
};
// -------------------------------------------------------------------

class ClientAuthRes : public ::google::protobuf::MessageLite {
 public:
  ClientAuthRes();
  virtual ~ClientAuthRes();

  ClientAuthRes(const ClientAuthRes& from);

  inline ClientAuthRes& operator=(const ClientAuthRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientAuthRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientAuthRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientAuthRes* other);

  // implements Message ----------------------------------------------

  ClientAuthRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientAuthRes& from);
  void MergeFrom(const ClientAuthRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::CBR::ErrorCode ret() const;
  inline void set_ret(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.ClientAuthRes)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  int ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static ClientAuthRes* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatData : public ::google::protobuf::MessageLite {
 public:
  HeartbeatData();
  virtual ~HeartbeatData();

  HeartbeatData(const HeartbeatData& from);

  inline HeartbeatData& operator=(const HeartbeatData& from) {
    CopyFrom(from);
    return *this;
  }

  static const HeartbeatData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeartbeatData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeartbeatData* other);

  // implements Message ----------------------------------------------

  HeartbeatData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeartbeatData& from);
  void MergeFrom(const HeartbeatData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.HeartbeatData)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatData* default_instance_;
};
// -------------------------------------------------------------------

class Friend2Db : public ::google::protobuf::MessageLite {
 public:
  Friend2Db();
  virtual ~Friend2Db();

  Friend2Db(const Friend2Db& from);

  inline Friend2Db& operator=(const Friend2Db& from) {
    CopyFrom(from);
    return *this;
  }

  static const Friend2Db& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Friend2Db* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Friend2Db* other);

  // implements Message ----------------------------------------------

  Friend2Db* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Friend2Db& from);
  void MergeFrom(const Friend2Db& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 actorid = 1;
  inline bool has_actorid() const;
  inline void clear_actorid();
  static const int kActoridFieldNumber = 1;
  inline ::google::protobuf::uint64 actorid() const;
  inline void set_actorid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CBR.Friend2Db)
 private:
  inline void set_has_actorid();
  inline void clear_has_actorid();

  ::google::protobuf::uint64 actorid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static Friend2Db* default_instance_;
};
// -------------------------------------------------------------------

class RegisterHallToDcmArg : public ::google::protobuf::MessageLite {
 public:
  RegisterHallToDcmArg();
  virtual ~RegisterHallToDcmArg();

  RegisterHallToDcmArg(const RegisterHallToDcmArg& from);

  inline RegisterHallToDcmArg& operator=(const RegisterHallToDcmArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterHallToDcmArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterHallToDcmArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterHallToDcmArg* other);

  // implements Message ----------------------------------------------

  RegisterHallToDcmArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterHallToDcmArg& from);
  void MergeFrom(const RegisterHallToDcmArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 serverid = 1;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 1;
  inline ::google::protobuf::uint32 serverid() const;
  inline void set_serverid(::google::protobuf::uint32 value);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:CBR.RegisterHallToDcmArg)
 private:
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* ip_;
  ::google::protobuf::uint32 serverid_;
  ::google::protobuf::uint32 port_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegisterHallToDcmArg* default_instance_;
};
// -------------------------------------------------------------------

class RegisterHallToDcmRes : public ::google::protobuf::MessageLite {
 public:
  RegisterHallToDcmRes();
  virtual ~RegisterHallToDcmRes();

  RegisterHallToDcmRes(const RegisterHallToDcmRes& from);

  inline RegisterHallToDcmRes& operator=(const RegisterHallToDcmRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegisterHallToDcmRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterHallToDcmRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterHallToDcmRes* other);

  // implements Message ----------------------------------------------

  RegisterHallToDcmRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterHallToDcmRes& from);
  void MergeFrom(const RegisterHallToDcmRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.RegisterHallToDcmRes)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RegisterHallToDcmRes* default_instance_;
};
// -------------------------------------------------------------------

class StartMatchArg : public ::google::protobuf::MessageLite {
 public:
  StartMatchArg();
  virtual ~StartMatchArg();

  StartMatchArg(const StartMatchArg& from);

  inline StartMatchArg& operator=(const StartMatchArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartMatchArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartMatchArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartMatchArg* other);

  // implements Message ----------------------------------------------

  StartMatchArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartMatchArg& from);
  void MergeFrom(const StartMatchArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 accountid = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 1;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // optional string accountname = 2;
  inline bool has_accountname() const;
  inline void clear_accountname();
  static const int kAccountnameFieldNumber = 2;
  inline const ::std::string& accountname() const;
  inline void set_accountname(const ::std::string& value);
  inline void set_accountname(const char* value);
  inline void set_accountname(const char* value, size_t size);
  inline ::std::string* mutable_accountname();
  inline ::std::string* release_accountname();
  inline void set_allocated_accountname(::std::string* accountname);

  // optional uint32 teamid = 3;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamidFieldNumber = 3;
  inline ::google::protobuf::uint32 teamid() const;
  inline void set_teamid(::google::protobuf::uint32 value);

  // optional .CBR.ENUM_MATCH_TYPE matchtype = 4;
  inline bool has_matchtype() const;
  inline void clear_matchtype();
  static const int kMatchtypeFieldNumber = 4;
  inline ::CBR::ENUM_MATCH_TYPE matchtype() const;
  inline void set_matchtype(::CBR::ENUM_MATCH_TYPE value);

  // @@protoc_insertion_point(class_scope:CBR.StartMatchArg)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_accountname();
  inline void clear_has_accountname();
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_matchtype();
  inline void clear_has_matchtype();

  ::google::protobuf::uint64 accountid_;
  ::std::string* accountname_;
  ::google::protobuf::uint32 teamid_;
  int matchtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static StartMatchArg* default_instance_;
};
// -------------------------------------------------------------------

class StartMatchRes : public ::google::protobuf::MessageLite {
 public:
  StartMatchRes();
  virtual ~StartMatchRes();

  StartMatchRes(const StartMatchRes& from);

  inline StartMatchRes& operator=(const StartMatchRes& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartMatchRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartMatchRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartMatchRes* other);

  // implements Message ----------------------------------------------

  StartMatchRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartMatchRes& from);
  void MergeFrom(const StartMatchRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CBR.ErrorCode error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline ::CBR::ErrorCode error() const;
  inline void set_error(::CBR::ErrorCode value);

  // @@protoc_insertion_point(class_scope:CBR.StartMatchRes)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  int error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static StartMatchRes* default_instance_;
};
// -------------------------------------------------------------------

class MatchPlayer : public ::google::protobuf::MessageLite {
 public:
  MatchPlayer();
  virtual ~MatchPlayer();

  MatchPlayer(const MatchPlayer& from);

  inline MatchPlayer& operator=(const MatchPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  static const MatchPlayer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MatchPlayer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MatchPlayer* other);

  // implements Message ----------------------------------------------

  MatchPlayer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MatchPlayer& from);
  void MergeFrom(const MatchPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 AccountId = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 accountid() const;
  inline void set_accountid(::google::protobuf::uint32 value);

  // optional string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 TeamId = 3;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamIdFieldNumber = 3;
  inline ::google::protobuf::uint32 teamid() const;
  inline void set_teamid(::google::protobuf::uint32 value);

  // optional uint32 HeroId = 4;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroIdFieldNumber = 4;
  inline ::google::protobuf::uint32 heroid() const;
  inline void set_heroid(::google::protobuf::uint32 value);

  // optional uint32 Grade = 5;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 5;
  inline ::google::protobuf::uint32 grade() const;
  inline void set_grade(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.MatchPlayer)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_heroid();
  inline void clear_has_heroid();
  inline void set_has_grade();
  inline void clear_has_grade();

  ::std::string* name_;
  ::google::protobuf::uint32 accountid_;
  ::google::protobuf::uint32 teamid_;
  ::google::protobuf::uint32 heroid_;
  ::google::protobuf::uint32 grade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static MatchPlayer* default_instance_;
};
// -------------------------------------------------------------------

class MatchResult : public ::google::protobuf::MessageLite {
 public:
  MatchResult();
  virtual ~MatchResult();

  MatchResult(const MatchResult& from);

  inline MatchResult& operator=(const MatchResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const MatchResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MatchResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MatchResult* other);

  // implements Message ----------------------------------------------

  MatchResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MatchResult& from);
  void MergeFrom(const MatchResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 AccountId = 1;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint64 accountid() const;
  inline void set_accountid(::google::protobuf::uint64 value);

  // optional string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 TeamId = 3;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamIdFieldNumber = 3;
  inline ::google::protobuf::uint32 teamid() const;
  inline void set_teamid(::google::protobuf::uint32 value);

  // optional uint32 HeroId = 4;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroIdFieldNumber = 4;
  inline ::google::protobuf::uint32 heroid() const;
  inline void set_heroid(::google::protobuf::uint32 value);

  // optional uint32 GameTime = 5;
  inline bool has_gametime() const;
  inline void clear_gametime();
  static const int kGameTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 gametime() const;
  inline void set_gametime(::google::protobuf::uint32 value);

  // optional uint32 KillCount = 6;
  inline bool has_killcount() const;
  inline void clear_killcount();
  static const int kKillCountFieldNumber = 6;
  inline ::google::protobuf::uint32 killcount() const;
  inline void set_killcount(::google::protobuf::uint32 value);

  // optional uint32 DamageCount = 7;
  inline bool has_damagecount() const;
  inline void clear_damagecount();
  static const int kDamageCountFieldNumber = 7;
  inline ::google::protobuf::uint32 damagecount() const;
  inline void set_damagecount(::google::protobuf::uint32 value);

  // optional uint32 RescueCount = 8;
  inline bool has_rescuecount() const;
  inline void clear_rescuecount();
  static const int kRescueCountFieldNumber = 8;
  inline ::google::protobuf::uint32 rescuecount() const;
  inline void set_rescuecount(::google::protobuf::uint32 value);

  // optional uint32 ReviveCount = 9;
  inline bool has_revivecount() const;
  inline void clear_revivecount();
  static const int kReviveCountFieldNumber = 9;
  inline ::google::protobuf::uint32 revivecount() const;
  inline void set_revivecount(::google::protobuf::uint32 value);

  // optional uint32 AssistCount = 10;
  inline bool has_assistcount() const;
  inline void clear_assistcount();
  static const int kAssistCountFieldNumber = 10;
  inline ::google::protobuf::uint32 assistcount() const;
  inline void set_assistcount(::google::protobuf::uint32 value);

  // optional uint32 RespawnCount = 11;
  inline bool has_respawncount() const;
  inline void clear_respawncount();
  static const int kRespawnCountFieldNumber = 11;
  inline ::google::protobuf::uint32 respawncount() const;
  inline void set_respawncount(::google::protobuf::uint32 value);

  // optional uint32 Grade = 12;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 12;
  inline ::google::protobuf::uint32 grade() const;
  inline void set_grade(::google::protobuf::uint32 value);

  // optional uint32 Exp = 13;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 13;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.MatchResult)
 private:
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_heroid();
  inline void clear_has_heroid();
  inline void set_has_gametime();
  inline void clear_has_gametime();
  inline void set_has_killcount();
  inline void clear_has_killcount();
  inline void set_has_damagecount();
  inline void clear_has_damagecount();
  inline void set_has_rescuecount();
  inline void clear_has_rescuecount();
  inline void set_has_revivecount();
  inline void clear_has_revivecount();
  inline void set_has_assistcount();
  inline void clear_has_assistcount();
  inline void set_has_respawncount();
  inline void clear_has_respawncount();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::uint64 accountid_;
  ::std::string* name_;
  ::google::protobuf::uint32 teamid_;
  ::google::protobuf::uint32 heroid_;
  ::google::protobuf::uint32 gametime_;
  ::google::protobuf::uint32 killcount_;
  ::google::protobuf::uint32 damagecount_;
  ::google::protobuf::uint32 rescuecount_;
  ::google::protobuf::uint32 revivecount_;
  ::google::protobuf::uint32 assistcount_;
  ::google::protobuf::uint32 respawncount_;
  ::google::protobuf::uint32 grade_;
  ::google::protobuf::uint32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static MatchResult* default_instance_;
};
// -------------------------------------------------------------------

class MatchRobot : public ::google::protobuf::MessageLite {
 public:
  MatchRobot();
  virtual ~MatchRobot();

  MatchRobot(const MatchRobot& from);

  inline MatchRobot& operator=(const MatchRobot& from) {
    CopyFrom(from);
    return *this;
  }

  static const MatchRobot& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MatchRobot* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MatchRobot* other);

  // implements Message ----------------------------------------------

  MatchRobot* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MatchRobot& from);
  void MergeFrom(const MatchRobot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 RobotId = 1;
  inline bool has_robotid() const;
  inline void clear_robotid();
  static const int kRobotIdFieldNumber = 1;
  inline ::google::protobuf::uint32 robotid() const;
  inline void set_robotid(::google::protobuf::uint32 value);

  // optional string RobotName = 2;
  inline bool has_robotname() const;
  inline void clear_robotname();
  static const int kRobotNameFieldNumber = 2;
  inline const ::std::string& robotname() const;
  inline void set_robotname(const ::std::string& value);
  inline void set_robotname(const char* value);
  inline void set_robotname(const char* value, size_t size);
  inline ::std::string* mutable_robotname();
  inline ::std::string* release_robotname();
  inline void set_allocated_robotname(::std::string* robotname);

  // optional uint32 TeamId = 3;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamIdFieldNumber = 3;
  inline ::google::protobuf::uint32 teamid() const;
  inline void set_teamid(::google::protobuf::uint32 value);

  // optional uint32 HeroId = 4;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroIdFieldNumber = 4;
  inline ::google::protobuf::uint32 heroid() const;
  inline void set_heroid(::google::protobuf::uint32 value);

  // optional uint32 LevelId = 5;
  inline bool has_levelid() const;
  inline void clear_levelid();
  static const int kLevelIdFieldNumber = 5;
  inline ::google::protobuf::uint32 levelid() const;
  inline void set_levelid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.MatchRobot)
 private:
  inline void set_has_robotid();
  inline void clear_has_robotid();
  inline void set_has_robotname();
  inline void clear_has_robotname();
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_heroid();
  inline void clear_has_heroid();
  inline void set_has_levelid();
  inline void clear_has_levelid();

  ::std::string* robotname_;
  ::google::protobuf::uint32 robotid_;
  ::google::protobuf::uint32 teamid_;
  ::google::protobuf::uint32 heroid_;
  ::google::protobuf::uint32 levelid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static MatchRobot* default_instance_;
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::MessageLite {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoomInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoomInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 RoomID = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::uint32 roomid() const;
  inline void set_roomid(::google::protobuf::uint32 value);

  // optional uint32 MapId = 2;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::uint32 mapid() const;
  inline void set_mapid(::google::protobuf::uint32 value);

  // repeated .CBR.MatchPlayer players = 3;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 3;
  inline const ::CBR::MatchPlayer& players(int index) const;
  inline ::CBR::MatchPlayer* mutable_players(int index);
  inline ::CBR::MatchPlayer* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::CBR::MatchPlayer >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::CBR::MatchPlayer >*
      mutable_players();

  // repeated .CBR.MatchRobot robots = 4;
  inline int robots_size() const;
  inline void clear_robots();
  static const int kRobotsFieldNumber = 4;
  inline const ::CBR::MatchRobot& robots(int index) const;
  inline ::CBR::MatchRobot* mutable_robots(int index);
  inline ::CBR::MatchRobot* add_robots();
  inline const ::google::protobuf::RepeatedPtrField< ::CBR::MatchRobot >&
      robots() const;
  inline ::google::protobuf::RepeatedPtrField< ::CBR::MatchRobot >*
      mutable_robots();

  // @@protoc_insertion_point(class_scope:CBR.RoomInfo)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_mapid();
  inline void clear_has_mapid();

  ::google::protobuf::uint32 roomid_;
  ::google::protobuf::uint32 mapid_;
  ::google::protobuf::RepeatedPtrField< ::CBR::MatchPlayer > players_;
  ::google::protobuf::RepeatedPtrField< ::CBR::MatchRobot > robots_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class CancelMatchArg : public ::google::protobuf::MessageLite {
 public:
  CancelMatchArg();
  virtual ~CancelMatchArg();

  CancelMatchArg(const CancelMatchArg& from);

  inline CancelMatchArg& operator=(const CancelMatchArg& from) {
    CopyFrom(from);
    return *this;
  }

  static const CancelMatchArg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CancelMatchArg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CancelMatchArg* other);

  // implements Message ----------------------------------------------

  CancelMatchArg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CancelMatchArg& from);
  void MergeFrom(const CancelMatchArg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 params = 1;
  inline bool has_params() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 1;
  inline ::google::protobuf::uint32 params() const;
  inline void set_params(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CBR.CancelMatchArg)
 private:
  inline void set_has_params();
  inline void clear_has_params();

  ::google::protobuf::uint32 params_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_project_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_project_2eproto();
  #endif
  friend void protobuf_AssignDesc_project_2eproto();
  friend void protobuf_ShutdownFile_project_2eproto();

  void InitAsDefaultInstance();
  static CancelMatchArg* default_instance_;
};
// ===================================================================


// ===================================================================

// npcdata

// optional int32 id = 1;
inline bool npcdata::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void npcdata::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void npcdata::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void npcdata::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 npcdata::id() const {
  return id_;
}
inline void npcdata::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 buff = 2;
inline bool npcdata::has_buff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void npcdata::set_has_buff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void npcdata::clear_has_buff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void npcdata::clear_buff() {
  buff_ = 0u;
  clear_has_buff();
}
inline ::google::protobuf::uint32 npcdata::buff() const {
  return buff_;
}
inline void npcdata::set_buff(::google::protobuf::uint32 value) {
  set_has_buff();
  buff_ = value;
}

// optional int32 appear = 3;
inline bool npcdata::has_appear() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void npcdata::set_has_appear() {
  _has_bits_[0] |= 0x00000004u;
}
inline void npcdata::clear_has_appear() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void npcdata::clear_appear() {
  appear_ = 0;
  clear_has_appear();
}
inline ::google::protobuf::int32 npcdata::appear() const {
  return appear_;
}
inline void npcdata::set_appear(::google::protobuf::int32 value) {
  set_has_appear();
  appear_ = value;
}

// optional int64 ff = 4;
inline bool npcdata::has_ff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void npcdata::set_has_ff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void npcdata::clear_has_ff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void npcdata::clear_ff() {
  ff_ = GOOGLE_LONGLONG(0);
  clear_has_ff();
}
inline ::google::protobuf::int64 npcdata::ff() const {
  return ff_;
}
inline void npcdata::set_ff(::google::protobuf::int64 value) {
  set_has_ff();
  ff_ = value;
}

// -------------------------------------------------------------------

// RegisterGateToHallRes

// optional .CBR.ErrorCode result = 1;
inline bool RegisterGateToHallRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterGateToHallRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterGateToHallRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterGateToHallRes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CBR::ErrorCode RegisterGateToHallRes::result() const {
  return static_cast< ::CBR::ErrorCode >(result_);
}
inline void RegisterGateToHallRes::set_result(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RegisterGateToHallReq

// optional uint32 zoneid = 1;
inline bool RegisterGateToHallReq::has_zoneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterGateToHallReq::set_has_zoneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterGateToHallReq::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterGateToHallReq::clear_zoneid() {
  zoneid_ = 0u;
  clear_has_zoneid();
}
inline ::google::protobuf::uint32 RegisterGateToHallReq::zoneid() const {
  return zoneid_;
}
inline void RegisterGateToHallReq::set_zoneid(::google::protobuf::uint32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// optional uint32 serverid = 2;
inline bool RegisterGateToHallReq::has_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterGateToHallReq::set_has_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterGateToHallReq::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterGateToHallReq::clear_serverid() {
  serverid_ = 0u;
  clear_has_serverid();
}
inline ::google::protobuf::uint32 RegisterGateToHallReq::serverid() const {
  return serverid_;
}
inline void RegisterGateToHallReq::set_serverid(::google::protobuf::uint32 value) {
  set_has_serverid();
  serverid_ = value;
}

// -------------------------------------------------------------------

// RegisterHallToDbReq

// optional uint32 serverid = 1;
inline bool RegisterHallToDbReq::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterHallToDbReq::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterHallToDbReq::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterHallToDbReq::clear_serverid() {
  serverid_ = 0u;
  clear_has_serverid();
}
inline ::google::protobuf::uint32 RegisterHallToDbReq::serverid() const {
  return serverid_;
}
inline void RegisterHallToDbReq::set_serverid(::google::protobuf::uint32 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional string name = 2;
inline bool RegisterHallToDbReq::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterHallToDbReq::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterHallToDbReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterHallToDbReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegisterHallToDbReq::name() const {
  return *name_;
}
inline void RegisterHallToDbReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterHallToDbReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterHallToDbReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterHallToDbReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegisterHallToDbReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterHallToDbReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterHallToDbRes

// optional .CBR.ErrorCode ret = 1;
inline bool RegisterHallToDbRes::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterHallToDbRes::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterHallToDbRes::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterHallToDbRes::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::CBR::ErrorCode RegisterHallToDbRes::ret() const {
  return static_cast< ::CBR::ErrorCode >(ret_);
}
inline void RegisterHallToDbRes::set_ret(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// UpRoleDataReq

// optional uint64 roleid = 1;
inline bool UpRoleDataReq::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpRoleDataReq::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpRoleDataReq::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpRoleDataReq::clear_roleid() {
  roleid_ = GOOGLE_ULONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::uint64 UpRoleDataReq::roleid() const {
  return roleid_;
}
inline void UpRoleDataReq::set_roleid(::google::protobuf::uint64 value) {
  set_has_roleid();
  roleid_ = value;
}

// optional string name = 2;
inline bool UpRoleDataReq::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpRoleDataReq::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpRoleDataReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpRoleDataReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UpRoleDataReq::name() const {
  return *name_;
}
inline void UpRoleDataReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UpRoleDataReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UpRoleDataReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpRoleDataReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UpRoleDataReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpRoleDataReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 score = 3;
inline bool UpRoleDataReq::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpRoleDataReq::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpRoleDataReq::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpRoleDataReq::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 UpRoleDataReq::score() const {
  return score_;
}
inline void UpRoleDataReq::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional uint32 killer = 4;
inline bool UpRoleDataReq::has_killer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpRoleDataReq::set_has_killer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpRoleDataReq::clear_has_killer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpRoleDataReq::clear_killer() {
  killer_ = 0u;
  clear_has_killer();
}
inline ::google::protobuf::uint32 UpRoleDataReq::killer() const {
  return killer_;
}
inline void UpRoleDataReq::set_killer(::google::protobuf::uint32 value) {
  set_has_killer();
  killer_ = value;
}

// -------------------------------------------------------------------

// UpRoleDataRes

// optional .CBR.ErrorCode error = 1;
inline bool UpRoleDataRes::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpRoleDataRes::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpRoleDataRes::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpRoleDataRes::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode UpRoleDataRes::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void UpRoleDataRes::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// -------------------------------------------------------------------

// DownRoleDataReq

// optional uint64 roleid = 1;
inline bool DownRoleDataReq::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownRoleDataReq::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownRoleDataReq::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownRoleDataReq::clear_roleid() {
  roleid_ = GOOGLE_ULONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::uint64 DownRoleDataReq::roleid() const {
  return roleid_;
}
inline void DownRoleDataReq::set_roleid(::google::protobuf::uint64 value) {
  set_has_roleid();
  roleid_ = value;
}

// -------------------------------------------------------------------

// DownRoleDataRes

// optional uint64 roleid = 1;
inline bool DownRoleDataRes::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownRoleDataRes::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownRoleDataRes::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownRoleDataRes::clear_roleid() {
  roleid_ = GOOGLE_ULONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::uint64 DownRoleDataRes::roleid() const {
  return roleid_;
}
inline void DownRoleDataRes::set_roleid(::google::protobuf::uint64 value) {
  set_has_roleid();
  roleid_ = value;
}

// optional string name = 2;
inline bool DownRoleDataRes::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DownRoleDataRes::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DownRoleDataRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DownRoleDataRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DownRoleDataRes::name() const {
  return *name_;
}
inline void DownRoleDataRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DownRoleDataRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DownRoleDataRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownRoleDataRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DownRoleDataRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DownRoleDataRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 score = 3;
inline bool DownRoleDataRes::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DownRoleDataRes::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DownRoleDataRes::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DownRoleDataRes::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 DownRoleDataRes::score() const {
  return score_;
}
inline void DownRoleDataRes::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional uint32 killer = 4;
inline bool DownRoleDataRes::has_killer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DownRoleDataRes::set_has_killer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DownRoleDataRes::clear_has_killer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DownRoleDataRes::clear_killer() {
  killer_ = 0u;
  clear_has_killer();
}
inline ::google::protobuf::uint32 DownRoleDataRes::killer() const {
  return killer_;
}
inline void DownRoleDataRes::set_killer(::google::protobuf::uint32 value) {
  set_has_killer();
  killer_ = value;
}

// -------------------------------------------------------------------

// ChickDinnerSaveData

// optional uint64 roleid = 1;
inline bool ChickDinnerSaveData::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChickDinnerSaveData::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChickDinnerSaveData::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChickDinnerSaveData::clear_roleid() {
  roleid_ = GOOGLE_ULONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::uint64 ChickDinnerSaveData::roleid() const {
  return roleid_;
}
inline void ChickDinnerSaveData::set_roleid(::google::protobuf::uint64 value) {
  set_has_roleid();
  roleid_ = value;
}

// optional string name = 2;
inline bool ChickDinnerSaveData::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChickDinnerSaveData::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChickDinnerSaveData::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChickDinnerSaveData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ChickDinnerSaveData::name() const {
  return *name_;
}
inline void ChickDinnerSaveData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChickDinnerSaveData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChickDinnerSaveData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChickDinnerSaveData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ChickDinnerSaveData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChickDinnerSaveData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 killer = 3;
inline bool ChickDinnerSaveData::has_killer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChickDinnerSaveData::set_has_killer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChickDinnerSaveData::clear_has_killer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChickDinnerSaveData::clear_killer() {
  killer_ = 0u;
  clear_has_killer();
}
inline ::google::protobuf::uint32 ChickDinnerSaveData::killer() const {
  return killer_;
}
inline void ChickDinnerSaveData::set_killer(::google::protobuf::uint32 value) {
  set_has_killer();
  killer_ = value;
}

// optional uint64 score = 4;
inline bool ChickDinnerSaveData::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChickDinnerSaveData::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChickDinnerSaveData::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChickDinnerSaveData::clear_score() {
  score_ = GOOGLE_ULONGLONG(0);
  clear_has_score();
}
inline ::google::protobuf::uint64 ChickDinnerSaveData::score() const {
  return score_;
}
inline void ChickDinnerSaveData::set_score(::google::protobuf::uint64 value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// ChickDinnerSaveDataArg

// optional .CBR.DBOperType type = 1;
inline bool ChickDinnerSaveDataArg::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChickDinnerSaveDataArg::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChickDinnerSaveDataArg::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChickDinnerSaveDataArg::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::CBR::DBOperType ChickDinnerSaveDataArg::type() const {
  return static_cast< ::CBR::DBOperType >(type_);
}
inline void ChickDinnerSaveDataArg::set_type(::CBR::DBOperType value) {
  assert(::CBR::DBOperType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .CBR.ChickDinnerSaveData data = 2;
inline bool ChickDinnerSaveDataArg::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChickDinnerSaveDataArg::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChickDinnerSaveDataArg::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChickDinnerSaveDataArg::clear_data() {
  if (data_ != NULL) data_->::CBR::ChickDinnerSaveData::Clear();
  clear_has_data();
}
inline const ::CBR::ChickDinnerSaveData& ChickDinnerSaveDataArg::data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_ != NULL ? *data_ : *default_instance().data_;
#else
  return data_ != NULL ? *data_ : *default_instance_->data_;
#endif
}
inline ::CBR::ChickDinnerSaveData* ChickDinnerSaveDataArg::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::CBR::ChickDinnerSaveData;
  return data_;
}
inline ::CBR::ChickDinnerSaveData* ChickDinnerSaveDataArg::release_data() {
  clear_has_data();
  ::CBR::ChickDinnerSaveData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void ChickDinnerSaveDataArg::set_allocated_data(::CBR::ChickDinnerSaveData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// ChickDinnerSaveDataRes

// optional .CBR.ErrorCode result = 1;
inline bool ChickDinnerSaveDataRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChickDinnerSaveDataRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChickDinnerSaveDataRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChickDinnerSaveDataRes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CBR::ErrorCode ChickDinnerSaveDataRes::result() const {
  return static_cast< ::CBR::ErrorCode >(result_);
}
inline void ChickDinnerSaveDataRes::set_result(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RegisterGateToLoginArg

// optional uint32 serverid = 1;
inline bool RegisterGateToLoginArg::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterGateToLoginArg::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterGateToLoginArg::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterGateToLoginArg::clear_serverid() {
  serverid_ = 0u;
  clear_has_serverid();
}
inline ::google::protobuf::uint32 RegisterGateToLoginArg::serverid() const {
  return serverid_;
}
inline void RegisterGateToLoginArg::set_serverid(::google::protobuf::uint32 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional string name = 2;
inline bool RegisterGateToLoginArg::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterGateToLoginArg::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterGateToLoginArg::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterGateToLoginArg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegisterGateToLoginArg::name() const {
  return *name_;
}
inline void RegisterGateToLoginArg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterGateToLoginArg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterGateToLoginArg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterGateToLoginArg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegisterGateToLoginArg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterGateToLoginArg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 3;
inline bool RegisterGateToLoginArg::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterGateToLoginArg::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterGateToLoginArg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterGateToLoginArg::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RegisterGateToLoginArg::ip() const {
  return *ip_;
}
inline void RegisterGateToLoginArg::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegisterGateToLoginArg::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegisterGateToLoginArg::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterGateToLoginArg::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RegisterGateToLoginArg::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterGateToLoginArg::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 4;
inline bool RegisterGateToLoginArg::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterGateToLoginArg::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterGateToLoginArg::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterGateToLoginArg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 RegisterGateToLoginArg::port() const {
  return port_;
}
inline void RegisterGateToLoginArg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// RegisterGateToLoginRes

// optional .CBR.ErrorCode result = 1;
inline bool RegisterGateToLoginRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterGateToLoginRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterGateToLoginRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterGateToLoginRes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CBR::ErrorCode RegisterGateToLoginRes::result() const {
  return static_cast< ::CBR::ErrorCode >(result_);
}
inline void RegisterGateToLoginRes::set_result(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ChickDinnerQueryDataArg

// optional uint64 roleid = 1;
inline bool ChickDinnerQueryDataArg::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChickDinnerQueryDataArg::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChickDinnerQueryDataArg::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChickDinnerQueryDataArg::clear_roleid() {
  roleid_ = GOOGLE_ULONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::uint64 ChickDinnerQueryDataArg::roleid() const {
  return roleid_;
}
inline void ChickDinnerQueryDataArg::set_roleid(::google::protobuf::uint64 value) {
  set_has_roleid();
  roleid_ = value;
}

// -------------------------------------------------------------------

// ChickDinnerQueryDataRes

// optional .CBR.ChickDinnerSaveData data = 1;
inline bool ChickDinnerQueryDataRes::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChickDinnerQueryDataRes::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChickDinnerQueryDataRes::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChickDinnerQueryDataRes::clear_data() {
  if (data_ != NULL) data_->::CBR::ChickDinnerSaveData::Clear();
  clear_has_data();
}
inline const ::CBR::ChickDinnerSaveData& ChickDinnerQueryDataRes::data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_ != NULL ? *data_ : *default_instance().data_;
#else
  return data_ != NULL ? *data_ : *default_instance_->data_;
#endif
}
inline ::CBR::ChickDinnerSaveData* ChickDinnerQueryDataRes::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::CBR::ChickDinnerSaveData;
  return data_;
}
inline ::CBR::ChickDinnerSaveData* ChickDinnerQueryDataRes::release_data() {
  clear_has_data();
  ::CBR::ChickDinnerSaveData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void ChickDinnerQueryDataRes::set_allocated_data(::CBR::ChickDinnerSaveData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional .CBR.ErrorCode error = 2;
inline bool ChickDinnerQueryDataRes::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChickDinnerQueryDataRes::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChickDinnerQueryDataRes::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChickDinnerQueryDataRes::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode ChickDinnerQueryDataRes::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void ChickDinnerQueryDataRes::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// -------------------------------------------------------------------

// RegAccountArg

// optional string name = 1;
inline bool RegAccountArg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegAccountArg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegAccountArg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegAccountArg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegAccountArg::name() const {
  return *name_;
}
inline void RegAccountArg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegAccountArg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegAccountArg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegAccountArg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegAccountArg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegAccountArg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool RegAccountArg::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegAccountArg::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegAccountArg::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegAccountArg::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RegAccountArg::password() const {
  return *password_;
}
inline void RegAccountArg::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RegAccountArg::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void RegAccountArg::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegAccountArg::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* RegAccountArg::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegAccountArg::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .CBR.Channel channnel = 3;
inline bool RegAccountArg::has_channnel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegAccountArg::set_has_channnel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegAccountArg::clear_has_channnel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegAccountArg::clear_channnel() {
  channnel_ = 0;
  clear_has_channnel();
}
inline ::CBR::Channel RegAccountArg::channnel() const {
  return static_cast< ::CBR::Channel >(channnel_);
}
inline void RegAccountArg::set_channnel(::CBR::Channel value) {
  assert(::CBR::Channel_IsValid(value));
  set_has_channnel();
  channnel_ = value;
}

// optional string DeviceId = 4;
inline bool RegAccountArg::has_deviceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegAccountArg::set_has_deviceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegAccountArg::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegAccountArg::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& RegAccountArg::deviceid() const {
  return *deviceid_;
}
inline void RegAccountArg::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void RegAccountArg::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void RegAccountArg::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegAccountArg::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* RegAccountArg::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegAccountArg::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 5;
inline bool RegAccountArg::has_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegAccountArg::set_has_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegAccountArg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegAccountArg::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RegAccountArg::ip() const {
  return *ip_;
}
inline void RegAccountArg::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegAccountArg::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegAccountArg::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegAccountArg::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RegAccountArg::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegAccountArg::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegAccountRes

// optional .CBR.ErrorCode error = 1;
inline bool RegAccountRes::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegAccountRes::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegAccountRes::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegAccountRes::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode RegAccountRes::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void RegAccountRes::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint64 accountid = 2;
inline bool RegAccountRes::has_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegAccountRes::set_has_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegAccountRes::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegAccountRes::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 RegAccountRes::accountid() const {
  return accountid_;
}
inline void RegAccountRes::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// -------------------------------------------------------------------

// LoginDataArg

// optional string name = 1;
inline bool LoginDataArg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginDataArg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginDataArg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginDataArg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LoginDataArg::name() const {
  return *name_;
}
inline void LoginDataArg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginDataArg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginDataArg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginDataArg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LoginDataArg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginDataArg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes passward = 2;
inline bool LoginDataArg::has_passward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginDataArg::set_has_passward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginDataArg::clear_has_passward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginDataArg::clear_passward() {
  if (passward_ != &::google::protobuf::internal::kEmptyString) {
    passward_->clear();
  }
  clear_has_passward();
}
inline const ::std::string& LoginDataArg::passward() const {
  return *passward_;
}
inline void LoginDataArg::set_passward(const ::std::string& value) {
  set_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    passward_ = new ::std::string;
  }
  passward_->assign(value);
}
inline void LoginDataArg::set_passward(const char* value) {
  set_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    passward_ = new ::std::string;
  }
  passward_->assign(value);
}
inline void LoginDataArg::set_passward(const void* value, size_t size) {
  set_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    passward_ = new ::std::string;
  }
  passward_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginDataArg::mutable_passward() {
  set_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    passward_ = new ::std::string;
  }
  return passward_;
}
inline ::std::string* LoginDataArg::release_passward() {
  clear_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passward_;
    passward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginDataArg::set_allocated_passward(::std::string* passward) {
  if (passward_ != &::google::protobuf::internal::kEmptyString) {
    delete passward_;
  }
  if (passward) {
    set_has_passward();
    passward_ = passward;
  } else {
    clear_has_passward();
    passward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceid = 3;
inline bool LoginDataArg::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginDataArg::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginDataArg::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginDataArg::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& LoginDataArg::deviceid() const {
  return *deviceid_;
}
inline void LoginDataArg::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginDataArg::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginDataArg::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginDataArg::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* LoginDataArg::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginDataArg::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 4;
inline bool LoginDataArg::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginDataArg::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginDataArg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginDataArg::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& LoginDataArg::ip() const {
  return *ip_;
}
inline void LoginDataArg::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void LoginDataArg::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void LoginDataArg::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginDataArg::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* LoginDataArg::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginDataArg::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginDataRes

// optional .CBR.ErrorCode result = 1;
inline bool LoginDataRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginDataRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginDataRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginDataRes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CBR::ErrorCode LoginDataRes::result() const {
  return static_cast< ::CBR::ErrorCode >(result_);
}
inline void LoginDataRes::set_result(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional string ip = 2;
inline bool LoginDataRes::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginDataRes::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginDataRes::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginDataRes::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& LoginDataRes::ip() const {
  return *ip_;
}
inline void LoginDataRes::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void LoginDataRes::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void LoginDataRes::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginDataRes::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* LoginDataRes::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginDataRes::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 3;
inline bool LoginDataRes::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginDataRes::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginDataRes::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginDataRes::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 LoginDataRes::port() const {
  return port_;
}
inline void LoginDataRes::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint64 session = 4;
inline bool LoginDataRes::has_session() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginDataRes::set_has_session() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginDataRes::clear_has_session() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginDataRes::clear_session() {
  session_ = GOOGLE_ULONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::uint64 LoginDataRes::session() const {
  return session_;
}
inline void LoginDataRes::set_session(::google::protobuf::uint64 value) {
  set_has_session();
  session_ = value;
}

// optional uint64 accoutid = 5;
inline bool LoginDataRes::has_accoutid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginDataRes::set_has_accoutid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginDataRes::clear_has_accoutid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginDataRes::clear_accoutid() {
  accoutid_ = GOOGLE_ULONGLONG(0);
  clear_has_accoutid();
}
inline ::google::protobuf::uint64 LoginDataRes::accoutid() const {
  return accoutid_;
}
inline void LoginDataRes::set_accoutid(::google::protobuf::uint64 value) {
  set_has_accoutid();
  accoutid_ = value;
}

// optional string accountname = 6;
inline bool LoginDataRes::has_accountname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginDataRes::set_has_accountname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginDataRes::clear_has_accountname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginDataRes::clear_accountname() {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    accountname_->clear();
  }
  clear_has_accountname();
}
inline const ::std::string& LoginDataRes::accountname() const {
  return *accountname_;
}
inline void LoginDataRes::set_accountname(const ::std::string& value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void LoginDataRes::set_accountname(const char* value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void LoginDataRes::set_accountname(const char* value, size_t size) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginDataRes::mutable_accountname() {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  return accountname_;
}
inline ::std::string* LoginDataRes::release_accountname() {
  clear_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountname_;
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginDataRes::set_allocated_accountname(::std::string* accountname) {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  if (accountname) {
    set_has_accountname();
    accountname_ = accountname;
  } else {
    clear_has_accountname();
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 state = 7;
inline bool LoginDataRes::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginDataRes::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginDataRes::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginDataRes::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 LoginDataRes::state() const {
  return state_;
}
inline void LoginDataRes::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// repeated .CBR.ActorBrief actorlist = 8;
inline int LoginDataRes::actorlist_size() const {
  return actorlist_.size();
}
inline void LoginDataRes::clear_actorlist() {
  actorlist_.Clear();
}
inline const ::CBR::ActorBrief& LoginDataRes::actorlist(int index) const {
  return actorlist_.Get(index);
}
inline ::CBR::ActorBrief* LoginDataRes::mutable_actorlist(int index) {
  return actorlist_.Mutable(index);
}
inline ::CBR::ActorBrief* LoginDataRes::add_actorlist() {
  return actorlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CBR::ActorBrief >&
LoginDataRes::actorlist() const {
  return actorlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::CBR::ActorBrief >*
LoginDataRes::mutable_actorlist() {
  return &actorlist_;
}

// -------------------------------------------------------------------

// appear

// optional uint64 actid = 1;
inline bool appear::has_actid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void appear::set_has_actid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void appear::clear_has_actid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void appear::clear_actid() {
  actid_ = GOOGLE_ULONGLONG(0);
  clear_has_actid();
}
inline ::google::protobuf::uint64 appear::actid() const {
  return actid_;
}
inline void appear::set_actid(::google::protobuf::uint64 value) {
  set_has_actid();
  actid_ = value;
}

// optional string actorname = 2;
inline bool appear::has_actorname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void appear::set_has_actorname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void appear::clear_has_actorname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void appear::clear_actorname() {
  if (actorname_ != &::google::protobuf::internal::kEmptyString) {
    actorname_->clear();
  }
  clear_has_actorname();
}
inline const ::std::string& appear::actorname() const {
  return *actorname_;
}
inline void appear::set_actorname(const ::std::string& value) {
  set_has_actorname();
  if (actorname_ == &::google::protobuf::internal::kEmptyString) {
    actorname_ = new ::std::string;
  }
  actorname_->assign(value);
}
inline void appear::set_actorname(const char* value) {
  set_has_actorname();
  if (actorname_ == &::google::protobuf::internal::kEmptyString) {
    actorname_ = new ::std::string;
  }
  actorname_->assign(value);
}
inline void appear::set_actorname(const char* value, size_t size) {
  set_has_actorname();
  if (actorname_ == &::google::protobuf::internal::kEmptyString) {
    actorname_ = new ::std::string;
  }
  actorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* appear::mutable_actorname() {
  set_has_actorname();
  if (actorname_ == &::google::protobuf::internal::kEmptyString) {
    actorname_ = new ::std::string;
  }
  return actorname_;
}
inline ::std::string* appear::release_actorname() {
  clear_has_actorname();
  if (actorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = actorname_;
    actorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void appear::set_allocated_actorname(::std::string* actorname) {
  if (actorname_ != &::google::protobuf::internal::kEmptyString) {
    delete actorname_;
  }
  if (actorname) {
    set_has_actorname();
    actorname_ = actorname;
  } else {
    clear_has_actorname();
    actorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 actortype = 3;
inline bool appear::has_actortype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void appear::set_has_actortype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void appear::clear_has_actortype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void appear::clear_actortype() {
  actortype_ = 0u;
  clear_has_actortype();
}
inline ::google::protobuf::uint32 appear::actortype() const {
  return actortype_;
}
inline void appear::set_actortype(::google::protobuf::uint32 value) {
  set_has_actortype();
  actortype_ = value;
}

// optional uint32 resid = 4;
inline bool appear::has_resid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void appear::set_has_resid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void appear::clear_has_resid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void appear::clear_resid() {
  resid_ = 0u;
  clear_has_resid();
}
inline ::google::protobuf::uint32 appear::resid() const {
  return resid_;
}
inline void appear::set_resid(::google::protobuf::uint32 value) {
  set_has_resid();
  resid_ = value;
}

// optional uint32 hairstyle = 5;
inline bool appear::has_hairstyle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void appear::set_has_hairstyle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void appear::clear_has_hairstyle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void appear::clear_hairstyle() {
  hairstyle_ = 0u;
  clear_has_hairstyle();
}
inline ::google::protobuf::uint32 appear::hairstyle() const {
  return hairstyle_;
}
inline void appear::set_hairstyle(::google::protobuf::uint32 value) {
  set_has_hairstyle();
  hairstyle_ = value;
}

// optional uint32 createtime = 6;
inline bool appear::has_createtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void appear::set_has_createtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void appear::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void appear::clear_createtime() {
  createtime_ = 0u;
  clear_has_createtime();
}
inline ::google::protobuf::uint32 appear::createtime() const {
  return createtime_;
}
inline void appear::set_createtime(::google::protobuf::uint32 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint32 sex = 7;
inline bool appear::has_sex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void appear::set_has_sex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void appear::clear_has_sex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void appear::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 appear::sex() const {
  return sex_;
}
inline void appear::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional uint32 seqindex = 8;
inline bool appear::has_seqindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void appear::set_has_seqindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void appear::clear_has_seqindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void appear::clear_seqindex() {
  seqindex_ = 0u;
  clear_has_seqindex();
}
inline ::google::protobuf::uint32 appear::seqindex() const {
  return seqindex_;
}
inline void appear::set_seqindex(::google::protobuf::uint32 value) {
  set_has_seqindex();
  seqindex_ = value;
}

// -------------------------------------------------------------------

// AttriBase

// optional uint32 ActorLevel = 1;
inline bool AttriBase::has_actorlevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttriBase::set_has_actorlevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttriBase::clear_has_actorlevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttriBase::clear_actorlevel() {
  actorlevel_ = 0u;
  clear_has_actorlevel();
}
inline ::google::protobuf::uint32 AttriBase::actorlevel() const {
  return actorlevel_;
}
inline void AttriBase::set_actorlevel(::google::protobuf::uint32 value) {
  set_has_actorlevel();
  actorlevel_ = value;
}

// optional uint64 ActorExp = 2;
inline bool AttriBase::has_actorexp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttriBase::set_has_actorexp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttriBase::clear_has_actorexp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttriBase::clear_actorexp() {
  actorexp_ = GOOGLE_ULONGLONG(0);
  clear_has_actorexp();
}
inline ::google::protobuf::uint64 AttriBase::actorexp() const {
  return actorexp_;
}
inline void AttriBase::set_actorexp(::google::protobuf::uint64 value) {
  set_has_actorexp();
  actorexp_ = value;
}

// optional uint32 Vigor = 3;
inline bool AttriBase::has_vigor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AttriBase::set_has_vigor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AttriBase::clear_has_vigor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AttriBase::clear_vigor() {
  vigor_ = 0u;
  clear_has_vigor();
}
inline ::google::protobuf::uint32 AttriBase::vigor() const {
  return vigor_;
}
inline void AttriBase::set_vigor(::google::protobuf::uint32 value) {
  set_has_vigor();
  vigor_ = value;
}

// optional uint32 VipLev = 4;
inline bool AttriBase::has_viplev() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AttriBase::set_has_viplev() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AttriBase::clear_has_viplev() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AttriBase::clear_viplev() {
  viplev_ = 0u;
  clear_has_viplev();
}
inline ::google::protobuf::uint32 AttriBase::viplev() const {
  return viplev_;
}
inline void AttriBase::set_viplev(::google::protobuf::uint32 value) {
  set_has_viplev();
  viplev_ = value;
}

// optional uint32 Fighting = 5;
inline bool AttriBase::has_fighting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AttriBase::set_has_fighting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AttriBase::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AttriBase::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 AttriBase::fighting() const {
  return fighting_;
}
inline void AttriBase::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 Fire = 6;
inline bool AttriBase::has_fire() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AttriBase::set_has_fire() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AttriBase::clear_has_fire() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AttriBase::clear_fire() {
  fire_ = 0u;
  clear_has_fire();
}
inline ::google::protobuf::uint32 AttriBase::fire() const {
  return fire_;
}
inline void AttriBase::set_fire(::google::protobuf::uint32 value) {
  set_has_fire();
  fire_ = value;
}

// optional uint32 score = 7;
inline bool AttriBase::has_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AttriBase::set_has_score() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AttriBase::clear_has_score() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AttriBase::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 AttriBase::score() const {
  return score_;
}
inline void AttriBase::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// ActorBase

// optional uint64 accountid = 1;
inline bool ActorBase::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorBase::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorBase::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorBase::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 ActorBase::accountid() const {
  return accountid_;
}
inline void ActorBase::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional .CBR.appear app = 2;
inline bool ActorBase::has_app() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorBase::set_has_app() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorBase::clear_has_app() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorBase::clear_app() {
  if (app_ != NULL) app_->::CBR::appear::Clear();
  clear_has_app();
}
inline const ::CBR::appear& ActorBase::app() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_ != NULL ? *app_ : *default_instance().app_;
#else
  return app_ != NULL ? *app_ : *default_instance_->app_;
#endif
}
inline ::CBR::appear* ActorBase::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::CBR::appear;
  return app_;
}
inline ::CBR::appear* ActorBase::release_app() {
  clear_has_app();
  ::CBR::appear* temp = app_;
  app_ = NULL;
  return temp;
}
inline void ActorBase::set_allocated_app(::CBR::appear* app) {
  delete app_;
  app_ = app;
  if (app) {
    set_has_app();
  } else {
    clear_has_app();
  }
}

// optional .CBR.AttriBase att = 3;
inline bool ActorBase::has_att() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorBase::set_has_att() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorBase::clear_has_att() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorBase::clear_att() {
  if (att_ != NULL) att_->::CBR::AttriBase::Clear();
  clear_has_att();
}
inline const ::CBR::AttriBase& ActorBase::att() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return att_ != NULL ? *att_ : *default_instance().att_;
#else
  return att_ != NULL ? *att_ : *default_instance_->att_;
#endif
}
inline ::CBR::AttriBase* ActorBase::mutable_att() {
  set_has_att();
  if (att_ == NULL) att_ = new ::CBR::AttriBase;
  return att_;
}
inline ::CBR::AttriBase* ActorBase::release_att() {
  clear_has_att();
  ::CBR::AttriBase* temp = att_;
  att_ = NULL;
  return temp;
}
inline void ActorBase::set_allocated_att(::CBR::AttriBase* att) {
  delete att_;
  att_ = att;
  if (att) {
    set_has_att();
  } else {
    clear_has_att();
  }
}

// optional uint32 verion = 4;
inline bool ActorBase::has_verion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActorBase::set_has_verion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActorBase::clear_has_verion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActorBase::clear_verion() {
  verion_ = 0u;
  clear_has_verion();
}
inline ::google::protobuf::uint32 ActorBase::verion() const {
  return verion_;
}
inline void ActorBase::set_verion(::google::protobuf::uint32 value) {
  set_has_verion();
  verion_ = value;
}

// optional uint32 time = 5;
inline bool ActorBase::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActorBase::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActorBase::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActorBase::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 ActorBase::time() const {
  return time_;
}
inline void ActorBase::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// LoginSession2Gate

// optional uint64 session = 1;
inline bool LoginSession2Gate::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginSession2Gate::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginSession2Gate::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginSession2Gate::clear_session() {
  session_ = GOOGLE_ULONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::uint64 LoginSession2Gate::session() const {
  return session_;
}
inline void LoginSession2Gate::set_session(::google::protobuf::uint64 value) {
  set_has_session();
  session_ = value;
}

// optional uint32 time = 2;
inline bool LoginSession2Gate::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginSession2Gate::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginSession2Gate::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginSession2Gate::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 LoginSession2Gate::time() const {
  return time_;
}
inline void LoginSession2Gate::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint64 accountid = 3;
inline bool LoginSession2Gate::has_accountid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginSession2Gate::set_has_accountid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginSession2Gate::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginSession2Gate::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 LoginSession2Gate::accountid() const {
  return accountid_;
}
inline void LoginSession2Gate::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional string accountname = 4;
inline bool LoginSession2Gate::has_accountname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginSession2Gate::set_has_accountname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginSession2Gate::clear_has_accountname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginSession2Gate::clear_accountname() {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    accountname_->clear();
  }
  clear_has_accountname();
}
inline const ::std::string& LoginSession2Gate::accountname() const {
  return *accountname_;
}
inline void LoginSession2Gate::set_accountname(const ::std::string& value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void LoginSession2Gate::set_accountname(const char* value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void LoginSession2Gate::set_accountname(const char* value, size_t size) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginSession2Gate::mutable_accountname() {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  return accountname_;
}
inline ::std::string* LoginSession2Gate::release_accountname() {
  clear_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountname_;
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginSession2Gate::set_allocated_accountname(::std::string* accountname) {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  if (accountname) {
    set_has_accountname();
    accountname_ = accountname;
  } else {
    clear_has_accountname();
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EnterGameArg

// optional uint64 accountid = 1;
inline bool EnterGameArg::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGameArg::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGameArg::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGameArg::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 EnterGameArg::accountid() const {
  return accountid_;
}
inline void EnterGameArg::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional uint64 token = 2;
inline bool EnterGameArg::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterGameArg::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterGameArg::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterGameArg::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 EnterGameArg::token() const {
  return token_;
}
inline void EnterGameArg::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// optional uint64 actorid = 3;
inline bool EnterGameArg::has_actorid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterGameArg::set_has_actorid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterGameArg::clear_has_actorid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterGameArg::clear_actorid() {
  actorid_ = GOOGLE_ULONGLONG(0);
  clear_has_actorid();
}
inline ::google::protobuf::uint64 EnterGameArg::actorid() const {
  return actorid_;
}
inline void EnterGameArg::set_actorid(::google::protobuf::uint64 value) {
  set_has_actorid();
  actorid_ = value;
}

// -------------------------------------------------------------------

// EnterGameRes

// optional .CBR.ErrorCode error = 1;
inline bool EnterGameRes::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGameRes::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGameRes::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGameRes::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode EnterGameRes::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void EnterGameRes::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// repeated .CBR.ActorBase actorlist = 2;
inline int EnterGameRes::actorlist_size() const {
  return actorlist_.size();
}
inline void EnterGameRes::clear_actorlist() {
  actorlist_.Clear();
}
inline const ::CBR::ActorBase& EnterGameRes::actorlist(int index) const {
  return actorlist_.Get(index);
}
inline ::CBR::ActorBase* EnterGameRes::mutable_actorlist(int index) {
  return actorlist_.Mutable(index);
}
inline ::CBR::ActorBase* EnterGameRes::add_actorlist() {
  return actorlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase >&
EnterGameRes::actorlist() const {
  return actorlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase >*
EnterGameRes::mutable_actorlist() {
  return &actorlist_;
}

// -------------------------------------------------------------------

// ActorDataArg

// optional int32 rpcid = 1;
inline bool ActorDataArg::has_rpcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorDataArg::set_has_rpcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorDataArg::clear_has_rpcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorDataArg::clear_rpcid() {
  rpcid_ = 0;
  clear_has_rpcid();
}
inline ::google::protobuf::int32 ActorDataArg::rpcid() const {
  return rpcid_;
}
inline void ActorDataArg::set_rpcid(::google::protobuf::int32 value) {
  set_has_rpcid();
  rpcid_ = value;
}

// optional uint64 actorid = 2;
inline bool ActorDataArg::has_actorid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorDataArg::set_has_actorid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorDataArg::clear_has_actorid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorDataArg::clear_actorid() {
  actorid_ = GOOGLE_ULONGLONG(0);
  clear_has_actorid();
}
inline ::google::protobuf::uint64 ActorDataArg::actorid() const {
  return actorid_;
}
inline void ActorDataArg::set_actorid(::google::protobuf::uint64 value) {
  set_has_actorid();
  actorid_ = value;
}

// optional uint64 sessionid = 3;
inline bool ActorDataArg::has_sessionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorDataArg::set_has_sessionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorDataArg::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorDataArg::clear_sessionid() {
  sessionid_ = GOOGLE_ULONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::uint64 ActorDataArg::sessionid() const {
  return sessionid_;
}
inline void ActorDataArg::set_sessionid(::google::protobuf::uint64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional uint64 accountid = 4;
inline bool ActorDataArg::has_accountid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActorDataArg::set_has_accountid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActorDataArg::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActorDataArg::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 ActorDataArg::accountid() const {
  return accountid_;
}
inline void ActorDataArg::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// -------------------------------------------------------------------

// ActorDataRes

// repeated .CBR.ActorBase actorlist = 1;
inline int ActorDataRes::actorlist_size() const {
  return actorlist_.size();
}
inline void ActorDataRes::clear_actorlist() {
  actorlist_.Clear();
}
inline const ::CBR::ActorBase& ActorDataRes::actorlist(int index) const {
  return actorlist_.Get(index);
}
inline ::CBR::ActorBase* ActorDataRes::mutable_actorlist(int index) {
  return actorlist_.Mutable(index);
}
inline ::CBR::ActorBase* ActorDataRes::add_actorlist() {
  return actorlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase >&
ActorDataRes::actorlist() const {
  return actorlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::CBR::ActorBase >*
ActorDataRes::mutable_actorlist() {
  return &actorlist_;
}

// optional .CBR.ErrorCode error = 2;
inline bool ActorDataRes::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorDataRes::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorDataRes::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorDataRes::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode ActorDataRes::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void ActorDataRes::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// optional uint32 rpcid = 3;
inline bool ActorDataRes::has_rpcid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorDataRes::set_has_rpcid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorDataRes::clear_has_rpcid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorDataRes::clear_rpcid() {
  rpcid_ = 0u;
  clear_has_rpcid();
}
inline ::google::protobuf::uint32 ActorDataRes::rpcid() const {
  return rpcid_;
}
inline void ActorDataRes::set_rpcid(::google::protobuf::uint32 value) {
  set_has_rpcid();
  rpcid_ = value;
}

// -------------------------------------------------------------------

// CreateActorReq

// optional uint32 hairid = 1;
inline bool CreateActorReq::has_hairid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateActorReq::set_has_hairid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateActorReq::clear_has_hairid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateActorReq::clear_hairid() {
  hairid_ = 0u;
  clear_has_hairid();
}
inline ::google::protobuf::uint32 CreateActorReq::hairid() const {
  return hairid_;
}
inline void CreateActorReq::set_hairid(::google::protobuf::uint32 value) {
  set_has_hairid();
  hairid_ = value;
}

// optional uint32 faceid = 2;
inline bool CreateActorReq::has_faceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateActorReq::set_has_faceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateActorReq::clear_has_faceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateActorReq::clear_faceid() {
  faceid_ = 0u;
  clear_has_faceid();
}
inline ::google::protobuf::uint32 CreateActorReq::faceid() const {
  return faceid_;
}
inline void CreateActorReq::set_faceid(::google::protobuf::uint32 value) {
  set_has_faceid();
  faceid_ = value;
}

// optional uint32 sex = 3;
inline bool CreateActorReq::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateActorReq::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateActorReq::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateActorReq::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 CreateActorReq::sex() const {
  return sex_;
}
inline void CreateActorReq::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string name = 4;
inline bool CreateActorReq::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateActorReq::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateActorReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateActorReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateActorReq::name() const {
  return *name_;
}
inline void CreateActorReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateActorReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateActorReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateActorReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CreateActorReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateActorReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 accountid = 5;
inline bool CreateActorReq::has_accountid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateActorReq::set_has_accountid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateActorReq::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateActorReq::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 CreateActorReq::accountid() const {
  return accountid_;
}
inline void CreateActorReq::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional uint32 seqindex = 6;
inline bool CreateActorReq::has_seqindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateActorReq::set_has_seqindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateActorReq::clear_has_seqindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateActorReq::clear_seqindex() {
  seqindex_ = 0u;
  clear_has_seqindex();
}
inline ::google::protobuf::uint32 CreateActorReq::seqindex() const {
  return seqindex_;
}
inline void CreateActorReq::set_seqindex(::google::protobuf::uint32 value) {
  set_has_seqindex();
  seqindex_ = value;
}

// optional uint32 actortype = 7;
inline bool CreateActorReq::has_actortype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateActorReq::set_has_actortype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateActorReq::clear_has_actortype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateActorReq::clear_actortype() {
  actortype_ = 0u;
  clear_has_actortype();
}
inline ::google::protobuf::uint32 CreateActorReq::actortype() const {
  return actortype_;
}
inline void CreateActorReq::set_actortype(::google::protobuf::uint32 value) {
  set_has_actortype();
  actortype_ = value;
}

// optional uint32 resid = 8;
inline bool CreateActorReq::has_resid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateActorReq::set_has_resid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateActorReq::clear_has_resid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateActorReq::clear_resid() {
  resid_ = 0u;
  clear_has_resid();
}
inline ::google::protobuf::uint32 CreateActorReq::resid() const {
  return resid_;
}
inline void CreateActorReq::set_resid(::google::protobuf::uint32 value) {
  set_has_resid();
  resid_ = value;
}

// optional uint32 rpcid = 9;
inline bool CreateActorReq::has_rpcid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateActorReq::set_has_rpcid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateActorReq::clear_has_rpcid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateActorReq::clear_rpcid() {
  rpcid_ = 0u;
  clear_has_rpcid();
}
inline ::google::protobuf::uint32 CreateActorReq::rpcid() const {
  return rpcid_;
}
inline void CreateActorReq::set_rpcid(::google::protobuf::uint32 value) {
  set_has_rpcid();
  rpcid_ = value;
}

// -------------------------------------------------------------------

// CreateActorRes

// optional .CBR.ErrorCode result = 1;
inline bool CreateActorRes::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateActorRes::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateActorRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateActorRes::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::CBR::ErrorCode CreateActorRes::result() const {
  return static_cast< ::CBR::ErrorCode >(result_);
}
inline void CreateActorRes::set_result(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional uint64 accoutid = 2;
inline bool CreateActorRes::has_accoutid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateActorRes::set_has_accoutid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateActorRes::clear_has_accoutid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateActorRes::clear_accoutid() {
  accoutid_ = GOOGLE_ULONGLONG(0);
  clear_has_accoutid();
}
inline ::google::protobuf::uint64 CreateActorRes::accoutid() const {
  return accoutid_;
}
inline void CreateActorRes::set_accoutid(::google::protobuf::uint64 value) {
  set_has_accoutid();
  accoutid_ = value;
}

// optional uint64 actorid = 3;
inline bool CreateActorRes::has_actorid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateActorRes::set_has_actorid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateActorRes::clear_has_actorid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateActorRes::clear_actorid() {
  actorid_ = GOOGLE_ULONGLONG(0);
  clear_has_actorid();
}
inline ::google::protobuf::uint64 CreateActorRes::actorid() const {
  return actorid_;
}
inline void CreateActorRes::set_actorid(::google::protobuf::uint64 value) {
  set_has_actorid();
  actorid_ = value;
}

// -------------------------------------------------------------------

// LoginOutData

// optional uint64 session = 1;
inline bool LoginOutData::has_session() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginOutData::set_has_session() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginOutData::clear_has_session() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginOutData::clear_session() {
  session_ = GOOGLE_ULONGLONG(0);
  clear_has_session();
}
inline ::google::protobuf::uint64 LoginOutData::session() const {
  return session_;
}
inline void LoginOutData::set_session(::google::protobuf::uint64 value) {
  set_has_session();
  session_ = value;
}

// optional .CBR.ErrorCode error = 2;
inline bool LoginOutData::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginOutData::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginOutData::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginOutData::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode LoginOutData::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void LoginOutData::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// -------------------------------------------------------------------

// UserSaveData

// optional uint64 accountid = 1;
inline bool UserSaveData::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSaveData::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSaveData::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSaveData::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 UserSaveData::accountid() const {
  return accountid_;
}
inline void UserSaveData::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional string accountname = 2;
inline bool UserSaveData::has_accountname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSaveData::set_has_accountname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSaveData::clear_has_accountname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSaveData::clear_accountname() {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    accountname_->clear();
  }
  clear_has_accountname();
}
inline const ::std::string& UserSaveData::accountname() const {
  return *accountname_;
}
inline void UserSaveData::set_accountname(const ::std::string& value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void UserSaveData::set_accountname(const char* value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void UserSaveData::set_accountname(const char* value, size_t size) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSaveData::mutable_accountname() {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  return accountname_;
}
inline ::std::string* UserSaveData::release_accountname() {
  clear_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountname_;
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSaveData::set_allocated_accountname(::std::string* accountname) {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  if (accountname) {
    set_has_accountname();
    accountname_ = accountname;
  } else {
    clear_has_accountname();
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 channel = 3;
inline bool UserSaveData::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserSaveData::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserSaveData::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserSaveData::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 UserSaveData::channel() const {
  return channel_;
}
inline void UserSaveData::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// optional string passward = 4;
inline bool UserSaveData::has_passward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserSaveData::set_has_passward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserSaveData::clear_has_passward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserSaveData::clear_passward() {
  if (passward_ != &::google::protobuf::internal::kEmptyString) {
    passward_->clear();
  }
  clear_has_passward();
}
inline const ::std::string& UserSaveData::passward() const {
  return *passward_;
}
inline void UserSaveData::set_passward(const ::std::string& value) {
  set_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    passward_ = new ::std::string;
  }
  passward_->assign(value);
}
inline void UserSaveData::set_passward(const char* value) {
  set_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    passward_ = new ::std::string;
  }
  passward_->assign(value);
}
inline void UserSaveData::set_passward(const char* value, size_t size) {
  set_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    passward_ = new ::std::string;
  }
  passward_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSaveData::mutable_passward() {
  set_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    passward_ = new ::std::string;
  }
  return passward_;
}
inline ::std::string* UserSaveData::release_passward() {
  clear_has_passward();
  if (passward_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passward_;
    passward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSaveData::set_allocated_passward(::std::string* passward) {
  if (passward_ != &::google::protobuf::internal::kEmptyString) {
    delete passward_;
  }
  if (passward) {
    set_has_passward();
    passward_ = passward;
  } else {
    clear_has_passward();
    passward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 isbind = 5;
inline bool UserSaveData::has_isbind() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserSaveData::set_has_isbind() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserSaveData::clear_has_isbind() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserSaveData::clear_isbind() {
  isbind_ = 0u;
  clear_has_isbind();
}
inline ::google::protobuf::uint32 UserSaveData::isbind() const {
  return isbind_;
}
inline void UserSaveData::set_isbind(::google::protobuf::uint32 value) {
  set_has_isbind();
  isbind_ = value;
}

// optional uint64 bindaccountid = 6;
inline bool UserSaveData::has_bindaccountid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserSaveData::set_has_bindaccountid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserSaveData::clear_has_bindaccountid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserSaveData::clear_bindaccountid() {
  bindaccountid_ = GOOGLE_ULONGLONG(0);
  clear_has_bindaccountid();
}
inline ::google::protobuf::uint64 UserSaveData::bindaccountid() const {
  return bindaccountid_;
}
inline void UserSaveData::set_bindaccountid(::google::protobuf::uint64 value) {
  set_has_bindaccountid();
  bindaccountid_ = value;
}

// optional uint32 bindtime = 7;
inline bool UserSaveData::has_bindtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserSaveData::set_has_bindtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserSaveData::clear_has_bindtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserSaveData::clear_bindtime() {
  bindtime_ = 0u;
  clear_has_bindtime();
}
inline ::google::protobuf::uint32 UserSaveData::bindtime() const {
  return bindtime_;
}
inline void UserSaveData::set_bindtime(::google::protobuf::uint32 value) {
  set_has_bindtime();
  bindtime_ = value;
}

// optional string deviceid = 8;
inline bool UserSaveData::has_deviceid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserSaveData::set_has_deviceid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserSaveData::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserSaveData::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& UserSaveData::deviceid() const {
  return *deviceid_;
}
inline void UserSaveData::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void UserSaveData::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void UserSaveData::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSaveData::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* UserSaveData::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSaveData::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 9;
inline bool UserSaveData::has_ip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserSaveData::set_has_ip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserSaveData::clear_has_ip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserSaveData::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UserSaveData::ip() const {
  return *ip_;
}
inline void UserSaveData::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UserSaveData::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UserSaveData::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSaveData::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UserSaveData::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSaveData::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 regtime = 10;
inline bool UserSaveData::has_regtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserSaveData::set_has_regtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserSaveData::clear_has_regtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserSaveData::clear_regtime() {
  regtime_ = 0u;
  clear_has_regtime();
}
inline ::google::protobuf::uint32 UserSaveData::regtime() const {
  return regtime_;
}
inline void UserSaveData::set_regtime(::google::protobuf::uint32 value) {
  set_has_regtime();
  regtime_ = value;
}

// optional uint32 state = 11;
inline bool UserSaveData::has_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserSaveData::set_has_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserSaveData::clear_has_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserSaveData::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 UserSaveData::state() const {
  return state_;
}
inline void UserSaveData::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// ActorInfo

// optional .CBR.ActorBase actor = 1;
inline bool ActorInfo::has_actor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorInfo::set_has_actor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorInfo::clear_has_actor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorInfo::clear_actor() {
  if (actor_ != NULL) actor_->::CBR::ActorBase::Clear();
  clear_has_actor();
}
inline const ::CBR::ActorBase& ActorInfo::actor() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actor_ != NULL ? *actor_ : *default_instance().actor_;
#else
  return actor_ != NULL ? *actor_ : *default_instance_->actor_;
#endif
}
inline ::CBR::ActorBase* ActorInfo::mutable_actor() {
  set_has_actor();
  if (actor_ == NULL) actor_ = new ::CBR::ActorBase;
  return actor_;
}
inline ::CBR::ActorBase* ActorInfo::release_actor() {
  clear_has_actor();
  ::CBR::ActorBase* temp = actor_;
  actor_ = NULL;
  return temp;
}
inline void ActorInfo::set_allocated_actor(::CBR::ActorBase* actor) {
  delete actor_;
  actor_ = actor;
  if (actor) {
    set_has_actor();
  } else {
    clear_has_actor();
  }
}

// -------------------------------------------------------------------

// ActorBrief

// optional uint64 id = 1;
inline bool ActorBrief::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorBrief::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorBrief::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorBrief::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ActorBrief::id() const {
  return id_;
}
inline void ActorBrief::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool ActorBrief::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorBrief::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorBrief::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorBrief::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ActorBrief::name() const {
  return *name_;
}
inline void ActorBrief::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ActorBrief::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ActorBrief::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActorBrief::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ActorBrief::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActorBrief::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UpdateActorDataArg

// optional .CBR.ActorBase act = 1;
inline bool UpdateActorDataArg::has_act() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateActorDataArg::set_has_act() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateActorDataArg::clear_has_act() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateActorDataArg::clear_act() {
  if (act_ != NULL) act_->::CBR::ActorBase::Clear();
  clear_has_act();
}
inline const ::CBR::ActorBase& UpdateActorDataArg::act() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return act_ != NULL ? *act_ : *default_instance().act_;
#else
  return act_ != NULL ? *act_ : *default_instance_->act_;
#endif
}
inline ::CBR::ActorBase* UpdateActorDataArg::mutable_act() {
  set_has_act();
  if (act_ == NULL) act_ = new ::CBR::ActorBase;
  return act_;
}
inline ::CBR::ActorBase* UpdateActorDataArg::release_act() {
  clear_has_act();
  ::CBR::ActorBase* temp = act_;
  act_ = NULL;
  return temp;
}
inline void UpdateActorDataArg::set_allocated_act(::CBR::ActorBase* act) {
  delete act_;
  act_ = act;
  if (act) {
    set_has_act();
  } else {
    clear_has_act();
  }
}

// -------------------------------------------------------------------

// UpdateActorDataRes

// optional .CBR.ErrorCode error = 1;
inline bool UpdateActorDataRes::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateActorDataRes::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateActorDataRes::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateActorDataRes::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode UpdateActorDataRes::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void UpdateActorDataRes::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// -------------------------------------------------------------------

// ClientAuthArg

// optional uint64 token = 1;
inline bool ClientAuthArg::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientAuthArg::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientAuthArg::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientAuthArg::clear_token() {
  token_ = GOOGLE_ULONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::uint64 ClientAuthArg::token() const {
  return token_;
}
inline void ClientAuthArg::set_token(::google::protobuf::uint64 value) {
  set_has_token();
  token_ = value;
}

// optional uint64 userid = 2;
inline bool ClientAuthArg::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientAuthArg::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientAuthArg::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientAuthArg::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 ClientAuthArg::userid() const {
  return userid_;
}
inline void ClientAuthArg::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// ClientAuthRes

// optional .CBR.ErrorCode ret = 1;
inline bool ClientAuthRes::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientAuthRes::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientAuthRes::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientAuthRes::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::CBR::ErrorCode ClientAuthRes::ret() const {
  return static_cast< ::CBR::ErrorCode >(ret_);
}
inline void ClientAuthRes::set_ret(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// HeartbeatData

// optional uint32 time = 1;
inline bool HeartbeatData::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatData::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatData::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatData::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 HeartbeatData::time() const {
  return time_;
}
inline void HeartbeatData::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// Friend2Db

// optional uint64 actorid = 1;
inline bool Friend2Db::has_actorid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Friend2Db::set_has_actorid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Friend2Db::clear_has_actorid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Friend2Db::clear_actorid() {
  actorid_ = GOOGLE_ULONGLONG(0);
  clear_has_actorid();
}
inline ::google::protobuf::uint64 Friend2Db::actorid() const {
  return actorid_;
}
inline void Friend2Db::set_actorid(::google::protobuf::uint64 value) {
  set_has_actorid();
  actorid_ = value;
}

// -------------------------------------------------------------------

// RegisterHallToDcmArg

// optional uint32 serverid = 1;
inline bool RegisterHallToDcmArg::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterHallToDcmArg::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterHallToDcmArg::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterHallToDcmArg::clear_serverid() {
  serverid_ = 0u;
  clear_has_serverid();
}
inline ::google::protobuf::uint32 RegisterHallToDcmArg::serverid() const {
  return serverid_;
}
inline void RegisterHallToDcmArg::set_serverid(::google::protobuf::uint32 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional string ip = 2;
inline bool RegisterHallToDcmArg::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterHallToDcmArg::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterHallToDcmArg::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterHallToDcmArg::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RegisterHallToDcmArg::ip() const {
  return *ip_;
}
inline void RegisterHallToDcmArg::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegisterHallToDcmArg::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegisterHallToDcmArg::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterHallToDcmArg::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RegisterHallToDcmArg::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterHallToDcmArg::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 port = 3;
inline bool RegisterHallToDcmArg::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterHallToDcmArg::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterHallToDcmArg::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterHallToDcmArg::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 RegisterHallToDcmArg::port() const {
  return port_;
}
inline void RegisterHallToDcmArg::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional string name = 4;
inline bool RegisterHallToDcmArg::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterHallToDcmArg::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterHallToDcmArg::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterHallToDcmArg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegisterHallToDcmArg::name() const {
  return *name_;
}
inline void RegisterHallToDcmArg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterHallToDcmArg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterHallToDcmArg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterHallToDcmArg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegisterHallToDcmArg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterHallToDcmArg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterHallToDcmRes

// optional .CBR.ErrorCode error = 1;
inline bool RegisterHallToDcmRes::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterHallToDcmRes::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterHallToDcmRes::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterHallToDcmRes::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode RegisterHallToDcmRes::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void RegisterHallToDcmRes::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// -------------------------------------------------------------------

// StartMatchArg

// optional uint64 accountid = 1;
inline bool StartMatchArg::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartMatchArg::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartMatchArg::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartMatchArg::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 StartMatchArg::accountid() const {
  return accountid_;
}
inline void StartMatchArg::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional string accountname = 2;
inline bool StartMatchArg::has_accountname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartMatchArg::set_has_accountname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartMatchArg::clear_has_accountname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartMatchArg::clear_accountname() {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    accountname_->clear();
  }
  clear_has_accountname();
}
inline const ::std::string& StartMatchArg::accountname() const {
  return *accountname_;
}
inline void StartMatchArg::set_accountname(const ::std::string& value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void StartMatchArg::set_accountname(const char* value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void StartMatchArg::set_accountname(const char* value, size_t size) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartMatchArg::mutable_accountname() {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  return accountname_;
}
inline ::std::string* StartMatchArg::release_accountname() {
  clear_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountname_;
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartMatchArg::set_allocated_accountname(::std::string* accountname) {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  if (accountname) {
    set_has_accountname();
    accountname_ = accountname;
  } else {
    clear_has_accountname();
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 teamid = 3;
inline bool StartMatchArg::has_teamid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartMatchArg::set_has_teamid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartMatchArg::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartMatchArg::clear_teamid() {
  teamid_ = 0u;
  clear_has_teamid();
}
inline ::google::protobuf::uint32 StartMatchArg::teamid() const {
  return teamid_;
}
inline void StartMatchArg::set_teamid(::google::protobuf::uint32 value) {
  set_has_teamid();
  teamid_ = value;
}

// optional .CBR.ENUM_MATCH_TYPE matchtype = 4;
inline bool StartMatchArg::has_matchtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartMatchArg::set_has_matchtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartMatchArg::clear_has_matchtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartMatchArg::clear_matchtype() {
  matchtype_ = 0;
  clear_has_matchtype();
}
inline ::CBR::ENUM_MATCH_TYPE StartMatchArg::matchtype() const {
  return static_cast< ::CBR::ENUM_MATCH_TYPE >(matchtype_);
}
inline void StartMatchArg::set_matchtype(::CBR::ENUM_MATCH_TYPE value) {
  assert(::CBR::ENUM_MATCH_TYPE_IsValid(value));
  set_has_matchtype();
  matchtype_ = value;
}

// -------------------------------------------------------------------

// StartMatchRes

// optional .CBR.ErrorCode error = 1;
inline bool StartMatchRes::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartMatchRes::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartMatchRes::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartMatchRes::clear_error() {
  error_ = 0;
  clear_has_error();
}
inline ::CBR::ErrorCode StartMatchRes::error() const {
  return static_cast< ::CBR::ErrorCode >(error_);
}
inline void StartMatchRes::set_error(::CBR::ErrorCode value) {
  assert(::CBR::ErrorCode_IsValid(value));
  set_has_error();
  error_ = value;
}

// -------------------------------------------------------------------

// MatchPlayer

// optional uint32 AccountId = 1;
inline bool MatchPlayer::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchPlayer::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchPlayer::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchPlayer::clear_accountid() {
  accountid_ = 0u;
  clear_has_accountid();
}
inline ::google::protobuf::uint32 MatchPlayer::accountid() const {
  return accountid_;
}
inline void MatchPlayer::set_accountid(::google::protobuf::uint32 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional string Name = 2;
inline bool MatchPlayer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchPlayer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchPlayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchPlayer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MatchPlayer::name() const {
  return *name_;
}
inline void MatchPlayer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MatchPlayer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MatchPlayer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchPlayer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MatchPlayer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchPlayer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 TeamId = 3;
inline bool MatchPlayer::has_teamid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchPlayer::set_has_teamid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchPlayer::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchPlayer::clear_teamid() {
  teamid_ = 0u;
  clear_has_teamid();
}
inline ::google::protobuf::uint32 MatchPlayer::teamid() const {
  return teamid_;
}
inline void MatchPlayer::set_teamid(::google::protobuf::uint32 value) {
  set_has_teamid();
  teamid_ = value;
}

// optional uint32 HeroId = 4;
inline bool MatchPlayer::has_heroid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatchPlayer::set_has_heroid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatchPlayer::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatchPlayer::clear_heroid() {
  heroid_ = 0u;
  clear_has_heroid();
}
inline ::google::protobuf::uint32 MatchPlayer::heroid() const {
  return heroid_;
}
inline void MatchPlayer::set_heroid(::google::protobuf::uint32 value) {
  set_has_heroid();
  heroid_ = value;
}

// optional uint32 Grade = 5;
inline bool MatchPlayer::has_grade() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MatchPlayer::set_has_grade() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MatchPlayer::clear_has_grade() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MatchPlayer::clear_grade() {
  grade_ = 0u;
  clear_has_grade();
}
inline ::google::protobuf::uint32 MatchPlayer::grade() const {
  return grade_;
}
inline void MatchPlayer::set_grade(::google::protobuf::uint32 value) {
  set_has_grade();
  grade_ = value;
}

// -------------------------------------------------------------------

// MatchResult

// optional uint64 AccountId = 1;
inline bool MatchResult::has_accountid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchResult::set_has_accountid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchResult::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchResult::clear_accountid() {
  accountid_ = GOOGLE_ULONGLONG(0);
  clear_has_accountid();
}
inline ::google::protobuf::uint64 MatchResult::accountid() const {
  return accountid_;
}
inline void MatchResult::set_accountid(::google::protobuf::uint64 value) {
  set_has_accountid();
  accountid_ = value;
}

// optional string Name = 2;
inline bool MatchResult::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchResult::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchResult::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchResult::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MatchResult::name() const {
  return *name_;
}
inline void MatchResult::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MatchResult::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MatchResult::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchResult::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MatchResult::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchResult::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 TeamId = 3;
inline bool MatchResult::has_teamid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchResult::set_has_teamid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchResult::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchResult::clear_teamid() {
  teamid_ = 0u;
  clear_has_teamid();
}
inline ::google::protobuf::uint32 MatchResult::teamid() const {
  return teamid_;
}
inline void MatchResult::set_teamid(::google::protobuf::uint32 value) {
  set_has_teamid();
  teamid_ = value;
}

// optional uint32 HeroId = 4;
inline bool MatchResult::has_heroid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatchResult::set_has_heroid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatchResult::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatchResult::clear_heroid() {
  heroid_ = 0u;
  clear_has_heroid();
}
inline ::google::protobuf::uint32 MatchResult::heroid() const {
  return heroid_;
}
inline void MatchResult::set_heroid(::google::protobuf::uint32 value) {
  set_has_heroid();
  heroid_ = value;
}

// optional uint32 GameTime = 5;
inline bool MatchResult::has_gametime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MatchResult::set_has_gametime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MatchResult::clear_has_gametime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MatchResult::clear_gametime() {
  gametime_ = 0u;
  clear_has_gametime();
}
inline ::google::protobuf::uint32 MatchResult::gametime() const {
  return gametime_;
}
inline void MatchResult::set_gametime(::google::protobuf::uint32 value) {
  set_has_gametime();
  gametime_ = value;
}

// optional uint32 KillCount = 6;
inline bool MatchResult::has_killcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MatchResult::set_has_killcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MatchResult::clear_has_killcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MatchResult::clear_killcount() {
  killcount_ = 0u;
  clear_has_killcount();
}
inline ::google::protobuf::uint32 MatchResult::killcount() const {
  return killcount_;
}
inline void MatchResult::set_killcount(::google::protobuf::uint32 value) {
  set_has_killcount();
  killcount_ = value;
}

// optional uint32 DamageCount = 7;
inline bool MatchResult::has_damagecount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MatchResult::set_has_damagecount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MatchResult::clear_has_damagecount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MatchResult::clear_damagecount() {
  damagecount_ = 0u;
  clear_has_damagecount();
}
inline ::google::protobuf::uint32 MatchResult::damagecount() const {
  return damagecount_;
}
inline void MatchResult::set_damagecount(::google::protobuf::uint32 value) {
  set_has_damagecount();
  damagecount_ = value;
}

// optional uint32 RescueCount = 8;
inline bool MatchResult::has_rescuecount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MatchResult::set_has_rescuecount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MatchResult::clear_has_rescuecount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MatchResult::clear_rescuecount() {
  rescuecount_ = 0u;
  clear_has_rescuecount();
}
inline ::google::protobuf::uint32 MatchResult::rescuecount() const {
  return rescuecount_;
}
inline void MatchResult::set_rescuecount(::google::protobuf::uint32 value) {
  set_has_rescuecount();
  rescuecount_ = value;
}

// optional uint32 ReviveCount = 9;
inline bool MatchResult::has_revivecount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MatchResult::set_has_revivecount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MatchResult::clear_has_revivecount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MatchResult::clear_revivecount() {
  revivecount_ = 0u;
  clear_has_revivecount();
}
inline ::google::protobuf::uint32 MatchResult::revivecount() const {
  return revivecount_;
}
inline void MatchResult::set_revivecount(::google::protobuf::uint32 value) {
  set_has_revivecount();
  revivecount_ = value;
}

// optional uint32 AssistCount = 10;
inline bool MatchResult::has_assistcount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MatchResult::set_has_assistcount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MatchResult::clear_has_assistcount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MatchResult::clear_assistcount() {
  assistcount_ = 0u;
  clear_has_assistcount();
}
inline ::google::protobuf::uint32 MatchResult::assistcount() const {
  return assistcount_;
}
inline void MatchResult::set_assistcount(::google::protobuf::uint32 value) {
  set_has_assistcount();
  assistcount_ = value;
}

// optional uint32 RespawnCount = 11;
inline bool MatchResult::has_respawncount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MatchResult::set_has_respawncount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MatchResult::clear_has_respawncount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MatchResult::clear_respawncount() {
  respawncount_ = 0u;
  clear_has_respawncount();
}
inline ::google::protobuf::uint32 MatchResult::respawncount() const {
  return respawncount_;
}
inline void MatchResult::set_respawncount(::google::protobuf::uint32 value) {
  set_has_respawncount();
  respawncount_ = value;
}

// optional uint32 Grade = 12;
inline bool MatchResult::has_grade() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MatchResult::set_has_grade() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MatchResult::clear_has_grade() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MatchResult::clear_grade() {
  grade_ = 0u;
  clear_has_grade();
}
inline ::google::protobuf::uint32 MatchResult::grade() const {
  return grade_;
}
inline void MatchResult::set_grade(::google::protobuf::uint32 value) {
  set_has_grade();
  grade_ = value;
}

// optional uint32 Exp = 13;
inline bool MatchResult::has_exp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MatchResult::set_has_exp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MatchResult::clear_has_exp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MatchResult::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 MatchResult::exp() const {
  return exp_;
}
inline void MatchResult::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// MatchRobot

// optional uint32 RobotId = 1;
inline bool MatchRobot::has_robotid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchRobot::set_has_robotid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchRobot::clear_has_robotid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchRobot::clear_robotid() {
  robotid_ = 0u;
  clear_has_robotid();
}
inline ::google::protobuf::uint32 MatchRobot::robotid() const {
  return robotid_;
}
inline void MatchRobot::set_robotid(::google::protobuf::uint32 value) {
  set_has_robotid();
  robotid_ = value;
}

// optional string RobotName = 2;
inline bool MatchRobot::has_robotname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchRobot::set_has_robotname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchRobot::clear_has_robotname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchRobot::clear_robotname() {
  if (robotname_ != &::google::protobuf::internal::kEmptyString) {
    robotname_->clear();
  }
  clear_has_robotname();
}
inline const ::std::string& MatchRobot::robotname() const {
  return *robotname_;
}
inline void MatchRobot::set_robotname(const ::std::string& value) {
  set_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    robotname_ = new ::std::string;
  }
  robotname_->assign(value);
}
inline void MatchRobot::set_robotname(const char* value) {
  set_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    robotname_ = new ::std::string;
  }
  robotname_->assign(value);
}
inline void MatchRobot::set_robotname(const char* value, size_t size) {
  set_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    robotname_ = new ::std::string;
  }
  robotname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchRobot::mutable_robotname() {
  set_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    robotname_ = new ::std::string;
  }
  return robotname_;
}
inline ::std::string* MatchRobot::release_robotname() {
  clear_has_robotname();
  if (robotname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = robotname_;
    robotname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchRobot::set_allocated_robotname(::std::string* robotname) {
  if (robotname_ != &::google::protobuf::internal::kEmptyString) {
    delete robotname_;
  }
  if (robotname) {
    set_has_robotname();
    robotname_ = robotname;
  } else {
    clear_has_robotname();
    robotname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 TeamId = 3;
inline bool MatchRobot::has_teamid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchRobot::set_has_teamid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchRobot::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchRobot::clear_teamid() {
  teamid_ = 0u;
  clear_has_teamid();
}
inline ::google::protobuf::uint32 MatchRobot::teamid() const {
  return teamid_;
}
inline void MatchRobot::set_teamid(::google::protobuf::uint32 value) {
  set_has_teamid();
  teamid_ = value;
}

// optional uint32 HeroId = 4;
inline bool MatchRobot::has_heroid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatchRobot::set_has_heroid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatchRobot::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatchRobot::clear_heroid() {
  heroid_ = 0u;
  clear_has_heroid();
}
inline ::google::protobuf::uint32 MatchRobot::heroid() const {
  return heroid_;
}
inline void MatchRobot::set_heroid(::google::protobuf::uint32 value) {
  set_has_heroid();
  heroid_ = value;
}

// optional uint32 LevelId = 5;
inline bool MatchRobot::has_levelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MatchRobot::set_has_levelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MatchRobot::clear_has_levelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MatchRobot::clear_levelid() {
  levelid_ = 0u;
  clear_has_levelid();
}
inline ::google::protobuf::uint32 MatchRobot::levelid() const {
  return levelid_;
}
inline void MatchRobot::set_levelid(::google::protobuf::uint32 value) {
  set_has_levelid();
  levelid_ = value;
}

// -------------------------------------------------------------------

// RoomInfo

// optional uint32 RoomID = 1;
inline bool RoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 RoomInfo::roomid() const {
  return roomid_;
}
inline void RoomInfo::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional uint32 MapId = 2;
inline bool RoomInfo::has_mapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_mapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_mapid() {
  mapid_ = 0u;
  clear_has_mapid();
}
inline ::google::protobuf::uint32 RoomInfo::mapid() const {
  return mapid_;
}
inline void RoomInfo::set_mapid(::google::protobuf::uint32 value) {
  set_has_mapid();
  mapid_ = value;
}

// repeated .CBR.MatchPlayer players = 3;
inline int RoomInfo::players_size() const {
  return players_.size();
}
inline void RoomInfo::clear_players() {
  players_.Clear();
}
inline const ::CBR::MatchPlayer& RoomInfo::players(int index) const {
  return players_.Get(index);
}
inline ::CBR::MatchPlayer* RoomInfo::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::CBR::MatchPlayer* RoomInfo::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CBR::MatchPlayer >&
RoomInfo::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::CBR::MatchPlayer >*
RoomInfo::mutable_players() {
  return &players_;
}

// repeated .CBR.MatchRobot robots = 4;
inline int RoomInfo::robots_size() const {
  return robots_.size();
}
inline void RoomInfo::clear_robots() {
  robots_.Clear();
}
inline const ::CBR::MatchRobot& RoomInfo::robots(int index) const {
  return robots_.Get(index);
}
inline ::CBR::MatchRobot* RoomInfo::mutable_robots(int index) {
  return robots_.Mutable(index);
}
inline ::CBR::MatchRobot* RoomInfo::add_robots() {
  return robots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CBR::MatchRobot >&
RoomInfo::robots() const {
  return robots_;
}
inline ::google::protobuf::RepeatedPtrField< ::CBR::MatchRobot >*
RoomInfo::mutable_robots() {
  return &robots_;
}

// -------------------------------------------------------------------

// CancelMatchArg

// optional uint32 params = 1;
inline bool CancelMatchArg::has_params() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelMatchArg::set_has_params() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelMatchArg::clear_has_params() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelMatchArg::clear_params() {
  params_ = 0u;
  clear_has_params();
}
inline ::google::protobuf::uint32 CancelMatchArg::params() const {
  return params_;
}
inline void CancelMatchArg::set_params(::google::protobuf::uint32 value) {
  set_has_params();
  params_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CBR

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_project_2eproto__INCLUDED
